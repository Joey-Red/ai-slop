<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bottle Flip 3D</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Inter", "Helvetica Neue", Arial, sans-serif;
        color: white;
      }

      #container {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        pointer-events: none; /* Allows clicks to pass through to the canvas */
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }

      .ui-element {
        display: none; /* Hidden by default */
        background: rgba(0, 0, 0, 0.5);
        padding: 15px 25px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }

      #score {
        display: block;
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 2em;
        font-weight: bold;
      }

      #message {
        display: none;
        font-size: 3em;
        font-weight: bold;
      }

      #instructions {
        display: block;
        font-size: 1.5em;
      }

      #resetButton {
        display: none;
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
        background: linear-gradient(145deg, #ffffff, #e6e6e6);
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        pointer-events: auto; /* Clickable */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease-in-out;
      }

      #resetButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3), 0 3px 6px rgba(0, 0, 0, 0.15);
      }

      .progress-bar-container {
        width: 80%;
        max-width: 400px;
        height: 30px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        border: 2px solid white;
        padding: 4px;
        box-sizing: border-box;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        border-radius: 10px;
        transition: width 0.1s linear;
      }

      #fill-bar {
        background: linear-gradient(90deg, #007bff, #00c6ff);
      }

      /* Sweet spot indicator */
      #fill-bar-container {
        position: relative;
      }
      #fill-bar-container::after {
        content: "";
        position: absolute;
        left: 30%; /* 30-36% range */
        width: 6%;
        height: 100%;
        top: 0;
        background: rgba(255, 255, 0, 0.3);
        border-left: 2px dashed yellow;
        border-right: 2px dashed yellow;
        box-sizing: border-box;
        z-index: -1;
      }

      #power-bar {
        background: linear-gradient(90deg, #ffc107, #f76b1c);
      }
    </style>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="container"></div>

    <div id="ui-overlay">
      <div id="score" class="ui-element">Score: 0</div>

      <div id="message" class="ui-element"></div>

      <div id="instructions" class="ui-element"></div>

      <div id="fill-bar-container" class="ui-element progress-bar-container">
        <div id="fill-bar" class="progress-bar"></div>
      </div>

      <div id="power-bar-container" class="ui-element progress-bar-container">
        <div id="power-bar" class="progress-bar"></div>
      </div>

      <button id="resetButton">Play Again</button>
    </div>

    <!-- Load Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script> -->
    <!-- Uncomment for debugging -->

    <script type="module">
      // Import necessary modules (OrbitControls is loaded globally if uncommented)
      // Note: For a single file, we'll access Three and Cannon from the global scope (window.THREE, window.CANNON)

      let scene, camera, renderer;
      let world; // Cannon.js physics world
      let bottleGroup, bottleMesh, waterMesh, capMesh; // Three.js visual
      let bottleBody; // Cannon.js physics body

      let tableMesh, floorMesh, spigotMesh;
      let tableBody, floorBody;

      let score = 0;
      let waterFillPercent = 0; // 0.0 to 1.0
      let flipPower = 0; // 0.0 to 1.0

      // Game State
      const STATES = {
        START: "START",
        FILLING: "FILLING",
        CAPPING: "CAPPING",
        AIMING: "AIMING",
        FLIPPING: "FLIPPING",
        LANDED: "LANDED",
        RESET: "RESET",
      };
      let gameState = STATES.START;

      // Input State
      let isCharging = false; // Used for both filling and power

      // Constants
      const BOTTLE_HEIGHT = 2.5;
      const BOTTLE_RADIUS = 0.4;
      const TABLE_POS = { x: 0, y: 5, z: 0 };
      const TABLE_SIZE = { x: 10, y: 1, z: 10 };
      const SPIGOT_POS = { x: -8, y: 10, z: 0 };

      // Camera Positions
      const CAM_POS = {
        START: new THREE.Vector3(-12, 12, 8),
        FLIP: new THREE.Vector3(0, 10, 15),
      };

      // UI Elements
      const ui = {
        score: document.getElementById("score"),
        message: document.getElementById("message"),
        instructions: document.getElementById("instructions"),
        fillBarContainer: document.getElementById("fill-bar-container"),
        fillBar: document.getElementById("fill-bar"),
        powerBarContainer: document.getElementById("power-bar-container"),
        powerBar: document.getElementById("power-bar"),
        resetButton: document.getElementById("resetButton"),
      };

      // --- CORE FUNCTIONS ---

      function init() {
        // 1. Setup Three.js Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

        // 2. Setup Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.copy(CAM_POS.START);
        camera.lookAt(SPIGOT_POS.x, SPIGOT_POS.y, SPIGOT_POS.z);

        // 3. Setup Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById("container").appendChild(renderer.domElement);

        // 4. Setup Lights
        const ambientLight = new THREE.AmbientLight(0x666666);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        scene.add(dirLight);

        // 5. Setup Physics World
        world = new CANNON.World();
        world.gravity.set(0, -30, 0); // Stronger gravity for a "game" feel
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Physics Materials
        const defaultMaterial = new CANNON.Material("default");
        const tableMaterial = new CANNON.Material("table");

        const default_table_contact = new CANNON.ContactMaterial(
          defaultMaterial,
          tableMaterial,
          {
            friction: 0.5,
            restitution: 0.1, // Not very bouncy
          }
        );
        world.addContactMaterial(default_table_contact);

        // 6. Create Scenery
        createScenery(defaultMaterial, tableMaterial);

        // 7. Create Bottle
        createBottle();

        // 8. Setup Controls (Optional Debug)
        // const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 9. Event Listeners
        window.addEventListener("resize", onWindowResize);
        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);
        ui.resetButton.addEventListener("click", resetGame);

        // 10. Start Game
        updateGameState(STATES.START);
        animate();
      }

      function createScenery(defaultMaterial, tableMaterial) {
        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
        floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        // Physics Floor
        floorBody = new CANNON.Body({
          mass: 0, // Static
          shape: new CANNON.Plane(),
          material: defaultMaterial,
        });
        floorBody.quaternion.setFromAxisAngle(
          new CANNON.Vec3(1, 0, 0),
          -Math.PI / 2
        );
        floorBody.position.set(0, 0, 0);
        world.addBody(floorBody);

        // Table
        const tableGeo = new THREE.BoxGeometry(
          TABLE_SIZE.x,
          TABLE_SIZE.y,
          TABLE_SIZE.z
        );
        const tableMat = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); // Brown
        tableMesh = new THREE.Mesh(tableGeo, tableMat);
        tableMesh.position.set(
          TABLE_POS.x,
          TABLE_POS.y - TABLE_SIZE.y / 2,
          TABLE_POS.z
        );
        tableMesh.castShadow = true;
        tableMesh.receiveShadow = true;
        scene.add(tableMesh);

        // Physics Table
        tableBody = new CANNON.Body({
          mass: 0, // Static
          shape: new CANNON.Box(
            new CANNON.Vec3(
              TABLE_SIZE.x / 2,
              TABLE_SIZE.y / 2,
              TABLE_SIZE.z / 2
            )
          ),
          material: tableMaterial,
        });
        tableBody.position.set(
          TABLE_POS.x,
          TABLE_POS.y - TABLE_SIZE.y / 2,
          TABLE_POS.z
        );
        world.addBody(tableBody);

        // Room (Backdrop)
        const roomGeo = new THREE.BoxGeometry(100, 50, 100);
        const roomMat = new THREE.MeshBasicMaterial({
          color: 0xadd8e6,
          side: THREE.BackSide,
        });
        const room = new THREE.Mesh(roomGeo, roomMat);
        room.position.y = 24.9;
        scene.add(room);

        // Spigot
        spigotMesh = new THREE.Group();
        const pipeGeo = new THREE.CylinderGeometry(0.2, 0.2, 3, 16);
        const pipeMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
        const mainPipe = new THREE.Mesh(pipeGeo, pipeMat);

        const nozzleGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 16);
        const nozzle = new THREE.Mesh(nozzleGeo, pipeMat);
        nozzle.position.y = -1.75;

        spigotMesh.add(mainPipe);
        spigotMesh.add(nozzle);
        spigotMesh.position.set(SPIGOT_POS.x, SPIGOT_POS.y, SPIGOT_POS.z);
        scene.add(spigotMesh);
      }

      function createBottle() {
        bottleGroup = new THREE.Group();

        const bottleMat = new THREE.MeshPhongMaterial({
          color: 0xadd8e6,
          transparent: true,
          opacity: 0.5,
        });

        // Main Bottle Body
        const bottleGeo = new THREE.CylinderGeometry(
          BOTTLE_RADIUS,
          BOTTLE_RADIUS,
          BOTTLE_HEIGHT,
          16
        );
        bottleMesh = new THREE.Mesh(bottleGeo, bottleMat);
        bottleMesh.castShadow = true;
        bottleGroup.add(bottleMesh);

        // Water inside
        const waterGeo = new THREE.CylinderGeometry(
          BOTTLE_RADIUS * 0.95,
          BOTTLE_RADIUS * 0.95,
          BOTTLE_HEIGHT,
          16
        );
        const waterMat = new THREE.MeshBasicMaterial({ color: 0x007bff });
        waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.scale.y = 0.001; // Start empty
        waterMesh.position.y = -BOTTLE_HEIGHT / 2; // Aligned with bottom
        waterMesh.castShadow = true;
        bottleGroup.add(waterMesh);

        // Cap
        const capGeo = new THREE.CylinderGeometry(
          BOTTLE_RADIUS * 0.7,
          BOTTLE_RADIUS * 0.8,
          0.3,
          16
        );
        const capMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red
        capMesh = new THREE.Mesh(capGeo, capMat);
        capMesh.position.y = BOTTLE_HEIGHT / 2 + 0.5; // Start above bottle
        capMesh.castShadow = true;
        bottleGroup.add(capMesh);

        scene.add(bottleGroup);

        // Set initial position
        bottleGroup.position.set(
          SPIGOT_POS.x,
          SPIGOT_POS.y - 3.5,
          SPIGOT_POS.z
        );
      }

      // --- GAME LOGIC & STATE ---

      function updateGameState(newState) {
        gameState = newState;

        // Reset all UI
        ui.message.style.display = "none";
        ui.instructions.style.display = "none";
        ui.fillBarContainer.style.display = "none";
        ui.powerBarContainer.style.display = "none";
        ui.resetButton.style.display = "none";

        switch (newState) {
          case STATES.START:
            ui.instructions.style.display = "block";
            ui.instructions.textContent = "Press [Space] to Start Filling";
            break;

          case STATES.FILLING:
            ui.instructions.style.display = "block";
            ui.instructions.textContent = "Hold [Space] to Fill";
            ui.fillBarContainer.style.display = "block";
            break;

          case STATES.CAPPING:
            // This is a transition state, no UI needed
            capBottle();
            break;

          case STATES.AIMING:
            ui.instructions.style.display = "block";
            ui.instructions.textContent = "Hold [Space] for Power";
            ui.powerBarContainer.style.display = "block";
            break;

          case STATES.FLIPPING:
            // No UI, just physics
            break;

          case STATES.LANDED:
            // Checked in animate loop, just a brief state
            break;

          case STATES.RESET:
            ui.message.style.display = "block";
            ui.resetButton.style.display = "block";
            break;
        }
      }

      function capBottle() {
        // Animate cap moving onto bottle
        const targetY = BOTTLE_HEIGHT / 2 + 0.15;
        const startY = capMesh.position.y;
        const duration = 500; // 0.5 sec
        let startTime = null;

        function anim(time) {
          if (startTime === null) startTime = time;
          const elapsed = time - startTime;
          const progress = Math.min(elapsed / duration, 1);

          capMesh.position.y = startY + (targetY - startY) * progress;

          if (progress < 1) {
            requestAnimationFrame(anim);
          } else {
            // Animation finished, move bottle to table
            moveBottleToTable();
          }
        }
        requestAnimationFrame(anim);
      }

      function moveBottleToTable() {
        // Animate bottle moving to table
        const targetPos = new THREE.Vector3(
          TABLE_POS.x,
          TABLE_POS.y + BOTTLE_HEIGHT / 2,
          TABLE_POS.z
        );
        const startPos = bottleGroup.position.clone();
        const duration = 1000; // 1 sec
        let startTime = null;

        // Also move camera
        const camStartPos = camera.position.clone();
        const camTargetPos = CAM_POS.FLIP.clone();

        const camStartLookAt = new THREE.Vector3(
          SPIGOT_POS.x,
          SPIGOT_POS.y,
          SPIGOT_POS.z
        );
        const camTargetLookAt = new THREE.Vector3(
          TABLE_POS.x,
          TABLE_POS.y + BOTTLE_HEIGHT / 2,
          TABLE_POS.z
        );

        function anim(time) {
          if (startTime === null) startTime = time;
          const elapsed = time - startTime;
          const progress = Math.min(elapsed / duration, 1.0);
          const easeProgress = 0.5 * (1 - Math.cos(progress * Math.PI)); // Ease-in-out

          bottleGroup.position.lerpVectors(startPos, targetPos, easeProgress);

          // Camera move
          camera.position.lerpVectors(camStartPos, camTargetPos, easeProgress);
          const currentLookAt = new THREE.Vector3().lerpVectors(
            camStartLookAt,
            camTargetLookAt,
            easeProgress
          );
          camera.lookAt(currentLookAt);

          if (progress < 1) {
            requestAnimationFrame(anim);
          } else {
            // Animation finished
            updateGameState(STATES.AIMING);
          }
        }
        requestAnimationFrame(anim);
      }

      function flipBottle() {
        if (bottleBody) return; // Already flipping

        // 1. Calculate physics properties based on fill level
        const emptyMass = 0.1;
        const waterMass = waterFillPercent * 1.0; // Max water mass is 1.0
        const totalMass = emptyMass + waterMass;

        // **** THIS IS THE CORE PHYSICS ****
        // The "magic" of bottle flipping is that the center of mass (CoM) changes.
        // A full bottle (CoM high) or empty bottle (CoM low) is stable.
        // A 1/3 full bottle has a CoM that is low, but the water has room to
        // slosh, transferring angular momentum in a complex way.
        // We simulate this with a "flipQuality" modifier.
        // The sweet spot is ~33% (0.33).

        const sweetSpot = 0.33;
        // This formula gives 1.0 at sweetSpot, and ~0.0 at 0.0 or 1.0
        const flipQuality =
          1.0 -
          (Math.abs(waterFillPercent - sweetSpot) * 1.5) /
            (sweetSpot * (1.0 - sweetSpot));
        const clampedQuality = Math.max(0.1, Math.min(1.0, flipQuality)); // Ensure it's never 0

        // 2. Create the physics body
        const bottleShape = new CANNON.Cylinder(
          BOTTLE_RADIUS,
          BOTTLE_RADIUS,
          BOTTLE_HEIGHT,
          16
        );
        bottleBody = new CANNON.Body({
          mass: totalMass,
          shape: bottleShape,
          material: world.defaultContactMaterial.materials[0], // defaultMaterial
        });
        bottleBody.position.copy(bottleGroup.position);

        // Adjust CoM visually/physically (simplified)
        // A true CoM adjustment is complex. We'll put it in the impulse instead.

        world.addBody(bottleBody);

        // 3. Apply impulse and angular velocity
        const upwardForce = flipPower * 25 * (1 + waterFillPercent * 0.2); // More power for heavier bottle
        const angularSpin = flipPower * 20 * clampedQuality; // *** Quality affects spin! ***

        // Apply impulse slightly off-center to induce a flip
        const impulse = new CANNON.Vec3(0, upwardForce, 0);
        const relativePoint = new CANNON.Vec3(0, -BOTTLE_HEIGHT / 2.1, 0); // Apply force near the bottom
        bottleBody.applyImpulse(impulse, relativePoint);

        // Add the angular velocity directly
        bottleBody.angularVelocity.set(angularSpin, 0, 0); // Flip forward
      }

      function checkLanding() {
        if (!bottleBody) return;

        // Check if bottle is resting
        const velocity = bottleBody.velocity.length();
        const angularVelocity = bottleBody.angularVelocity.length();

        // Wait until it's "at rest"
        if (velocity < 0.1 && angularVelocity < 0.1) {
          // Get the bottle's "up" vector (local Y) in world coordinates
          const localUp = new CANNON.Vec3(0, 1, 0);
          const worldUp = bottleBody.quaternion.vmult(localUp);

          // Check dot product with world's "up" (0, 1, 0)
          const dot = worldUp.dot(new CANNON.Vec3(0, 1, 0));

          if (dot > 0.98) {
            // > 0.98 is very upright
            ui.message.textContent = "LANDED! +100";
            score += 100;
            // Make bottle static so it doesn't fall
            bottleBody.type = CANNON.Body.STATIC;
          } else {
            ui.message.textContent = "Failed!";
          }

          ui.score.textContent = `Score: ${score}`;
          updateGameState(STATES.RESET);
        }
      }

      function resetGame() {
        // Remove physics body
        if (bottleBody) {
          world.removeBody(bottleBody);
          bottleBody = null;
        }

        // Reset variables
        waterFillPercent = 0;
        flipPower = 0;
        isCharging = false;

        // Reset bottle visual
        bottleGroup.position.set(
          SPIGOT_POS.x,
          SPIGOT_POS.y - 3.5,
          SPIGOT_POS.z
        );
        bottleGroup.quaternion.set(0, 0, 0, 1);
        capMesh.position.y = BOTTLE_HEIGHT / 2 + 0.5; // Cap off
        waterMesh.scale.y = 0.001; // Empty
        waterMesh.position.y = -BOTTLE_HEIGHT / 2;

        // Reset UI
        ui.fillBar.style.width = "0%";
        ui.powerBar.style.width = "0%";

        // Reset Camera
        camera.position.copy(CAM_POS.START);
        camera.lookAt(SPIGOT_POS.x, SPIGOT_POS.y, SPIGOT_POS.z);

        updateGameState(STATES.START);
      }

      // --- EVENT HANDLERS ---

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onKeyDown(event) {
        if (event.code !== "Space" || isCharging) return;

        switch (gameState) {
          case STATES.START:
            isCharging = true;
            updateGameState(STATES.FILLING);
            break;

          case STATES.FILLING:
            isCharging = true;
            break;

          case STATES.AIMING:
            isCharging = true;
            flipPower = 0; // Start charging
            ui.powerBar.style.width = "0%";
            break;
        }
      }

      function onKeyUp(event) {
        if (event.code !== "Space") return;

        isCharging = false;

        if (gameState === STATES.FILLING) {
          updateGameState(STATES.CAPPING);
        } else if (gameState === STATES.AIMING) {
          updateGameState(STATES.FLIPPING);
          flipBottle();
        }
      }

      // --- ANIMATION LOOP ---

      let lastTime = 0;
      let sleepTimer = 0;

      function animate(time) {
        requestAnimationFrame(animate);

        const deltaTime = (time - lastTime) / 1000 || 0;
        lastTime = time;

        // Game Logic Updates
        if (isCharging) {
          if (gameState === STATES.FILLING) {
            waterFillPercent = Math.min(
              1.0,
              waterFillPercent + deltaTime * 0.25
            ); // 4 seconds to fill
            waterMesh.scale.y = waterFillPercent;
            // Adjust position so it fills from the bottom up
            waterMesh.position.y =
              -BOTTLE_HEIGHT / 2 + (BOTTLE_HEIGHT * waterFillPercent) / 2;
            ui.fillBar.style.width = `${waterFillPercent * 100}%`;
          } else if (gameState === STATES.AIMING) {
            flipPower = Math.min(1.0, flipPower + deltaTime * 0.5); // 2 seconds to max power
            ui.powerBar.style.width = `${flipPower * 100}%`;
          }
        }

        // Physics Update
        if (gameState === STATES.FLIPPING) {
          world.step(1 / 60, deltaTime, 3); // Update physics

          if (bottleBody) {
            // Sync visual to physics
            bottleGroup.position.copy(bottleBody.position);
            bottleGroup.quaternion.copy(bottleBody.quaternion);

            // Check if it's on the table and has stopped moving
            if (bottleBody.position.y < TABLE_POS.y + BOTTLE_HEIGHT) {
              sleepTimer += deltaTime;
              // Wait 0.5s after it seems to be on the table before checking
              if (sleepTimer > 0.5) {
                checkLanding();
              }
            }
          }
        } else {
          sleepTimer = 0;
        }

        // Render
        renderer.render(scene, camera);
      }

      // --- START ---
      init();
    </script>
  </body>
</html>
