<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ice Cream Bike Vendor</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #87ceeb;
        font-family: "Courier New", Courier, monospace;
      }
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      #hud-top {
        padding: 20px;
        display: flex;
        justify-content: space-between;
        color: white;
        text-shadow: 2px 2px 0 #000;
        font-size: 24px;
        font-weight: bold;
      }
      #instructions {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
        color: white;
        text-shadow: 1px 1px 0 #000;
        font-size: 18px;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px 0;
      }
      #message-box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 40px;
        color: #ffeb3b;
        text-shadow: 3px 3px 0 #d32f2f;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.3s;
        text-align: center;
      }
      .visible {
        opacity: 1 !important;
      }
    </style>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="ui-layer">
      <div id="hud-top">
        <div id="score-display">Score: 0</div>
        <div id="quality-display">Last Swirl: -</div>
      </div>
      <div id="message-box">PERFECT SWIRL!</div>
      <div id="instructions">
        HOLD click on LEVER to pour • MOVE to swirl • RELEASE to finish • CLICK
        to Throw
      </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      /**
       * ICE CREAM BIKE VENDOR
       * A Three.js game handling physics, collisions, and interaction.
       */

      // --- Game State ---
      const STATE = {
        IDLE: 0,
        DISPENSING: 1,
        AIMING: 2,
        THROWN: 3,
      };

      let currentState = STATE.IDLE;
      let score = 0;
      let lastSwirlQuality = 0; // 0 to 1

      // --- Scene Setup ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // Sky blue
      scene.fog = new THREE.Fog(0x87ceeb, 20, 60);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 3.5, 6);
      camera.lookAt(0, 1, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // --- Lights ---
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -20;
      dirLight.shadow.camera.right = 20;
      dirLight.shadow.camera.top = 20;
      dirLight.shadow.camera.bottom = -20;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // --- Materials (Procedural Textures) ---

      function createStripedTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, 128, 128);
        ctx.fillStyle = "#e53935"; // Red stripes
        for (let i = 0; i < 128; i += 32) {
          ctx.fillRect(i, 0, 16, 128);
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
      }

      const matRoad = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const matSidewalk = new THREE.MeshLambertMaterial({ color: 0x999999 });
      const matGrass = new THREE.MeshLambertMaterial({ color: 0x4caf50 });
      const matCartBody = new THREE.MeshPhongMaterial({ color: 0xffffff });
      const matCartAwning = new THREE.MeshLambertMaterial({
        map: createStripedTexture(),
      });
      const matMetal = new THREE.MeshStandardMaterial({
        color: 0xaaaaaa,
        roughness: 0.4,
        metalness: 0.6,
      });
      const matTire = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
      const matCone = new THREE.MeshLambertMaterial({ color: 0xf4d03f }); // Waffle color
      const matIceCream = new THREE.MeshPhongMaterial({
        color: 0xffebee,
        shininess: 100,
      }); // Pinkish vanilla
      const matLeverKnob = new THREE.MeshLambertMaterial({ color: 0xd32f2f }); // Red knob

      // --- Game Objects Containers ---
      const pedestrians = [];
      const splats = [];
      let activeCone = null;
      let leverObj = null;
      let nozzlePos = new THREE.Vector3();

      // --- Environment Generation ---
      function createEnvironment() {
        // Road
        const roadGeo = new THREE.PlaneGeometry(100, 100);
        const road = new THREE.Mesh(roadGeo, matRoad);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        // Sidewalk (Pedestrian path)
        const walkGeo = new THREE.BoxGeometry(100, 0.2, 6);
        const walk = new THREE.Mesh(walkGeo, matSidewalk);
        walk.position.set(0, 0.1, -6); // Behind the cart
        walk.receiveShadow = true;
        scene.add(walk);

        // Grass/Buildings Background
        for (let i = 0; i < 10; i++) {
          // Buildings
          const h = 5 + Math.random() * 10;
          const w = 4 + Math.random() * 3;
          const d = 4 + Math.random() * 3;
          const bGeo = new THREE.BoxGeometry(w, h, d);
          const bMat = new THREE.MeshLambertMaterial({
            color: Math.random() * 0xffffff,
          });
          const building = new THREE.Mesh(bGeo, bMat);
          building.position.set(-40 + i * 10, h / 2, -12);
          building.castShadow = true;
          scene.add(building);
        }
      }

      // --- Cart Generation ---
      function createCart() {
        const cartGroup = new THREE.Group();

        // Box Body
        const boxGeo = new THREE.BoxGeometry(2, 1.5, 1.2);
        const box = new THREE.Mesh(boxGeo, matCartBody);
        box.position.y = 1.2;
        box.castShadow = true;
        cartGroup.add(box);

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
        wheelGeo.rotateZ(Math.PI / 2);

        const w1 = new THREE.Mesh(wheelGeo, matTire);
        w1.position.set(1.1, 0.5, 0.3);
        cartGroup.add(w1);

        const w2 = new THREE.Mesh(wheelGeo, matTire);
        w2.position.set(1.1, 0.5, -0.3);
        cartGroup.add(w2);

        const w3 = new THREE.Mesh(wheelGeo, matTire); // Trike style
        w3.position.set(-0.8, 0.5, 0);
        cartGroup.add(w3);

        // Awning Poles
        const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 2);
        const p1 = new THREE.Mesh(poleGeo, matMetal);
        p1.position.set(0.9, 2.2, 0.5);
        cartGroup.add(p1);
        const p2 = new THREE.Mesh(poleGeo, matMetal);
        p2.position.set(-0.9, 2.2, 0.5);
        cartGroup.add(p2);
        const p3 = new THREE.Mesh(poleGeo, matMetal);
        p3.position.set(0.9, 2.2, -0.5);
        cartGroup.add(p3);
        const p4 = new THREE.Mesh(poleGeo, matMetal);
        p4.position.set(-0.9, 2.2, -0.5);
        cartGroup.add(p4);

        // Awning
        const awningGeo = new THREE.BoxGeometry(2.2, 0.2, 1.4);
        const awning = new THREE.Mesh(awningGeo, matCartAwning);
        awning.position.set(0, 3.2, 0);
        awning.castShadow = true;
        cartGroup.add(awning);

        // Ice Cream Machine
        const machGeo = new THREE.BoxGeometry(0.6, 0.8, 0.6);
        const machine = new THREE.Mesh(machGeo, matMetal);
        machine.position.set(0.3, 2.3, 0);
        machine.castShadow = true;
        cartGroup.add(machine);

        // Nozzle
        const nozGeo = new THREE.CylinderGeometry(0.05, 0.1, 0.2);
        const nozzle = new THREE.Mesh(nozGeo, matMetal);
        nozzle.position.set(0.3, 1.9, 0.2); // Front of machine
        cartGroup.add(nozzle);

        // Save nozzle world pos for dispensing logic
        cartGroup.updateMatrixWorld();
        nozzlePos.setFromMatrixPosition(nozzle.matrixWorld);
        nozzlePos.y -= 0.1; // Spawn slightly below

        // Lever (Interactable)
        const leverGroup = new THREE.Group();
        leverGroup.position.set(0.65, 2.3, 0.2);

        const stickGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4);
        const stick = new THREE.Mesh(stickGeo, matMetal);
        stick.position.y = 0.2;

        const knobGeo = new THREE.SphereGeometry(0.08);
        const knob = new THREE.Mesh(knobGeo, matLeverKnob);
        knob.position.y = 0.4;

        leverGroup.add(stick);
        leverGroup.add(knob);
        leverGroup.rotation.x = 0; // Initial rotation

        cartGroup.add(leverGroup);
        leverObj = leverGroup; // Global ref

        scene.add(cartGroup);
      }

      // --- Cone Class ---
      class IceCreamCone {
        constructor() {
          this.group = new THREE.Group();

          // Cone wafer
          const geo = new THREE.ConeGeometry(0.15, 0.6, 16);
          geo.translate(0, 0.3, 0); // Pivot at bottom
          this.mesh = new THREE.Mesh(geo, matCone);
          this.mesh.rotation.x = Math.PI; // Point down
          this.mesh.castShadow = true;
          this.group.add(this.mesh);

          // Ice cream container
          this.creamGroup = new THREE.Group();
          this.group.add(this.creamGroup);

          this.blobs = [];
          this.velocity = new THREE.Vector3();
          this.isFlying = false;
          this.angularVelocity = new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          );

          scene.add(this.group);
        }

        addBlob(xOffset, zOffset) {
          const scale = Math.max(0.2, 1.0 - this.blobs.length * 0.05);
          const blobGeo = new THREE.SphereGeometry(0.12 * scale, 16, 16);
          const blob = new THREE.Mesh(blobGeo, matIceCream);

          // Stack height
          const yPos = 0.6 + this.blobs.length * 0.15;

          // Offset relative to cone center (simulates wobble/swirl)
          blob.position.set(xOffset, yPos, zOffset);

          this.creamGroup.add(blob);
          this.blobs.push(blob);
        }

        update(dt) {
          if (this.isFlying) {
            this.velocity.y -= 9.8 * dt; // Gravity
            this.group.position.add(this.velocity.clone().multiplyScalar(dt));

            // Rotate while flying
            this.group.rotation.x += this.angularVelocity.x * dt * 5;
            this.group.rotation.y += this.angularVelocity.y * dt * 5;

            // Floor Collision
            if (this.group.position.y < 0) {
              this.splat(this.group.position);
              return true; // Destroy signal
            }
          }
          return false;
        }

        splat(pos) {
          createSplatEffect(pos);
          scene.remove(this.group);
        }

        calculateQuality() {
          if (this.blobs.length === 0) return 0;

          // Calculate variance from center
          let totalDist = 0;
          this.blobs.forEach((b) => {
            const dist = Math.sqrt(b.position.x ** 2 + b.position.z ** 2);
            totalDist += dist;
          });

          const avgOffset = totalDist / this.blobs.length;
          // Lower offset = higher score. Also reward height (more blobs).

          let stability = Math.max(0, 1 - avgOffset * 5); // 0.2 offset is fail
          let heightBonus = Math.min(1, this.blobs.length / 10);

          return stability * 0.7 + heightBonus * 0.3;
        }
      }

      // --- Pedestrians ---
      class Pedestrian {
        constructor() {
          this.group = new THREE.Group();

          const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
          const matShirt = new THREE.MeshLambertMaterial({ color: color });
          const matPants = new THREE.MeshLambertMaterial({ color: 0x222222 });
          const matSkin = new THREE.MeshLambertMaterial({ color: 0xffccaa });

          // Body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.7, 0.3),
            matShirt
          );
          body.position.y = 1.3;
          this.group.add(body);

          // Head
          const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            matSkin
          );
          head.position.y = 1.8;
          this.group.add(head);

          // Legs (Pivot point for animation)
          this.legL = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.9, 0.15),
            matPants
          );
          this.legL.position.set(-0.15, 0.45, 0);
          this.group.add(this.legL);

          this.legR = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.9, 0.15),
            matPants
          );
          this.legR.position.set(0.15, 0.45, 0);
          this.group.add(this.legR);

          // Start Pos
          this.dir = Math.random() > 0.5 ? 1 : -1;
          this.speed = 2 + Math.random() * 2;
          this.group.position.set(
            -40 * this.dir,
            0,
            -6 + (Math.random() * 2 - 1)
          );

          this.isHit = false;
          this.hitTimer = 0;

          scene.add(this.group);
        }

        update(dt, time) {
          if (this.isHit) {
            // Run away or spin
            this.group.rotation.y += 10 * dt;
            this.group.scale.y -= 2 * dt; // Shrink/fall
            if (this.group.scale.y <= 0.1) return true; // Remove
            return false;
          }

          // Move
          this.group.position.x += this.dir * this.speed * dt;

          // Animate Legs
          this.legL.rotation.x = Math.sin(time * 10) * 0.5;
          this.legR.rotation.x = Math.sin(time * 10 + Math.PI) * 0.5;
          this.legL.position.z = Math.sin(time * 10) * 0.1;
          this.legR.position.z = Math.sin(time * 10 + Math.PI) * 0.1;

          // Bounds check
          if (this.group.position.x > 50 || this.group.position.x < -50)
            return true;

          return false;
        }

        checkHit(cone) {
          if (this.isHit) return false;
          const dist = this.group.position.distanceTo(cone.group.position);
          if (dist < 1.0) {
            this.isHit = true;
            createSplatEffect(cone.group.position);
            return true;
          }
          return false;
        }
      }

      // --- Particles (Splats) ---
      function createSplatEffect(pos) {
        const particleCount = 15;
        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const mat = matIceCream;

        for (let i = 0; i < particleCount; i++) {
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.copy(pos);
          mesh.position.x += (Math.random() - 0.5) * 0.5;
          mesh.position.z += (Math.random() - 0.5) * 0.5;

          const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 4,
            Math.random() * 4,
            (Math.random() - 0.5) * 4
          );

          splats.push({ mesh, vel, age: 0 });
          scene.add(mesh);
        }
      }

      function updateSplats(dt) {
        for (let i = splats.length - 1; i >= 0; i--) {
          const p = splats[i];
          p.age += dt;
          p.vel.y -= 9.8 * dt;
          p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
          p.mesh.rotation.x += dt;

          if (p.mesh.position.y < 0.05) {
            p.mesh.position.y = 0.05;
            p.vel.set(0, 0, 0); // Stick to ground
          }

          if (p.age > 2.0) {
            scene.remove(p.mesh);
            splats.splice(i, 1);
          }
        }
      }

      // --- Input Handling ---
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let isMouseDown = false;
      let targetConePos = new THREE.Vector3(); // Where the player wants the cone to be

      window.addEventListener("mousemove", (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        if (currentState === STATE.DISPENSING && activeCone) {
          // Project mouse to a plane at nozzle height
          raycaster.setFromCamera(mouse, camera);
          const planeY = nozzlePos.y - 0.5;
          const planeNormal = new THREE.Vector3(0, 1, 0);
          const plane = new THREE.Plane(planeNormal, -planeY);
          const target = new THREE.Vector3();

          raycaster.ray.intersectPlane(plane, target);

          if (target) {
            // Limit range so you can't go too far from nozzle
            const range = 0.4;
            target.x = Math.max(
              nozzlePos.x - range,
              Math.min(nozzlePos.x + range, target.x)
            );
            target.z = Math.max(
              nozzlePos.z - range,
              Math.min(nozzlePos.z + range, target.z)
            );
            target.y = nozzlePos.y - 0.6; // Cone holding height

            targetConePos.copy(target);
          }
        }

        // Aiming Logic
        if (currentState === STATE.AIMING && activeCone) {
          // Just follow camera cursor logic roughly for visual
          raycaster.setFromCamera(mouse, camera);
          const pos = new THREE.Vector3();
          raycaster.ray.at(2, pos); // 2 units in front of camera
          activeCone.group.position.lerp(pos, 0.1);
          activeCone.group.lookAt(
            pos.clone().add(camera.getWorldDirection(new THREE.Vector3()))
          );
        }
      });

      window.addEventListener("mousedown", () => {
        if (currentState === STATE.IDLE) {
          // Check if clicked lever
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(leverObj, true);

          if (intersects.length > 0) {
            startDispensing();
          }
        } else if (currentState === STATE.AIMING) {
          throwCone();
        }
        isMouseDown = true;
      });

      window.addEventListener("mouseup", () => {
        if (currentState === STATE.DISPENSING) {
          stopDispensing();
        }
        isMouseDown = false;
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // --- Game Logic Functions ---

      function startDispensing() {
        currentState = STATE.DISPENSING;
        activeCone = new IceCreamCone();
        activeCone.group.position.set(
          nozzlePos.x,
          nozzlePos.y - 0.6,
          nozzlePos.z
        );
        targetConePos.copy(activeCone.group.position);

        // Animate Lever
        leverObj.rotation.x = Math.PI / 4;
      }

      let dispenseTimer = 0;

      function stopDispensing() {
        leverObj.rotation.x = 0; // Reset Lever

        if (!activeCone) return;

        // Calculate Score
        const q = activeCone.calculateQuality();
        lastSwirlQuality = q;

        const qText = Math.floor(q * 100);
        document.getElementById(
          "quality-display"
        ).innerText = `Last Swirl: ${qText}%`;

        let msg = "";
        if (q > 0.9) msg = "PERFECT!";
        else if (q > 0.7) msg = "GREAT!";
        else if (q > 0.4) msg = "OKAY";
        else msg = "MESSY...";

        showMessage(msg);

        currentState = STATE.AIMING;
      }

      function throwCone() {
        currentState = STATE.THROWN;

        // Vector from camera center
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

        const throwDir = raycaster.ray.direction.clone();
        activeCone.velocity.copy(throwDir.multiplyScalar(15)); // Throw speed
        activeCone.velocity.y += 2; // Little arc up

        activeCone.isFlying = true;
      }

      function showMessage(text) {
        const el = document.getElementById("message-box");
        el.innerText = text;
        el.classList.add("visible");
        setTimeout(() => {
          el.classList.remove("visible");
        }, 1500);
      }

      // --- Main Loop ---
      createEnvironment();
      createCart();

      let lastTime = 0;
      let pedestrianTimer = 0;

      function animate(time) {
        requestAnimationFrame(animate);

        const dt = Math.min((time - lastTime) / 1000, 0.1);
        lastTime = time;

        // 1. Handle Dispensing
        if (currentState === STATE.DISPENSING && activeCone) {
          dispenseTimer += dt;

          // Smoothly move cone to mouse position
          activeCone.group.position.lerp(targetConePos, 10 * dt);

          // Add blobs periodically
          if (dispenseTimer > 0.1) {
            dispenseTimer = 0;
            // Calculate offset based on cone position relative to nozzle
            // The nozzle is at nozzlePos. If cone moves Left, blob lands Right on the cone
            const relX = nozzlePos.x - activeCone.group.position.x;
            const relZ = nozzlePos.z - activeCone.group.position.z;

            activeCone.addBlob(relX, relZ);

            // Limit max size
            if (activeCone.blobs.length > 15) {
              stopDispensing(); // Force stop if too big
            }
          }
        }

        // 2. Handle Thrown Cone
        if (currentState === STATE.THROWN && activeCone) {
          const destroyed = activeCone.update(dt);

          // Check Pedestrian Hits
          if (!destroyed) {
            for (const ped of pedestrians) {
              if (ped.checkHit(activeCone)) {
                const points = Math.floor(100 * (1 + lastSwirlQuality));
                score += points;
                document.getElementById(
                  "score-display"
                ).innerText = `Score: ${score}`;
                showMessage(`HIT! +${points}`);
                activeCone.splat(activeCone.group.position); // Visual destroy
                scene.remove(activeCone.group);
                activeCone = null;
                currentState = STATE.IDLE;
                break;
              }
            }
          } else {
            // Hit ground
            activeCone = null;
            currentState = STATE.IDLE;
          }
        }

        // 3. Pedestrian Spawning & Logic
        pedestrianTimer += dt;
        if (pedestrianTimer > 2.5) {
          pedestrianTimer = 0;
          pedestrians.push(new Pedestrian());
        }

        for (let i = pedestrians.length - 1; i >= 0; i--) {
          const remove = pedestrians[i].update(dt, time / 1000);
          if (remove) {
            scene.remove(pedestrians[i].group);
            pedestrians.splice(i, 1);
          }
        }

        updateSplats(dt);

        renderer.render(scene, camera);
      }

      animate(0);
    </script>
  </body>
</html>
