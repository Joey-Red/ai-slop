<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project: Vice Sandbox (Three.js)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        user-select: none;
      }
      #game-ui {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      #hud-top {
        padding: 20px;
        display: flex;
        justify-content: space-between;
        color: rgba(255, 255, 255, 0.9);
        text-shadow: 0 0 10px #ff00de;
      }
      .star-level {
        color: #ffcc00;
        font-size: 24px;
      }
      #hud-bottom {
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
      }
      #interaction-prompt {
        position: absolute;
        top: 60%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-weight: bold;
        display: none;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      #controls-help {
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        color: #ccc;
      }
      #minimap {
        width: 150px;
        height: 150px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #fff;
        border-radius: 50%;
        position: relative;
        overflow: hidden;
      }
      #minimap-player {
        position: absolute;
        width: 6px;
        height: 6px;
        background: #ff00de;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        box-shadow: 0 0 5px #ff00de;
      }
      .title-text {
        font-size: 32px;
        font-weight: 900;
        background: linear-gradient(45deg, #ff00de, #00d4ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-style: italic;
      }
      #loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #111;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 999;
        transition: opacity 0.5s;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="loading">Generating City...</div>

    <div id="game-ui">
      <div id="hud-top">
        <div>
          <div class="title-text">VICE BOX VI</div>
          <div style="font-size: 14px; opacity: 0.7">$ 000,000,000</div>
        </div>
        <div class="star-level">★★☆☆☆</div>
      </div>

      <div id="interaction-prompt">Press F to Enter Vehicle</div>

      <div id="hud-bottom">
        <div id="controls-help">
          <b>WASD</b> Move/Drive<br />
          <b>F</b> Enter/Exit Car<br />
          <b>SHIFT</b> Sprint/Turbo<br />
          <b>SPACE</b> Jump/Brake
        </div>
        <div id="minimap">
          <div id="minimap-player"></div>
        </div>
      </div>
    </div>

    <script>
      // --- CONFIGURATION ---
      const WORLD_SIZE = 600;
      const BUILDING_COUNT = 150;
      const CAR_COUNT = 10;

      // --- GLOBALS ---
      let scene, camera, renderer;
      let clock = new THREE.Clock();
      let player,
        city,
        cars = [];
      let keys = {};
      let gameState = {
        mode: "on_foot", // 'on_foot' or 'driving'
        currentCar: null,
        mouseTime: 0,
      };

      // Input Handling
      document.addEventListener("keydown", (e) => (keys[e.code] = true));
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      // Mouse Control for Camera
      let cameraAngle = 0;
      let cameraVerticalAngle = 0.3;
      document.addEventListener("mousemove", (e) => {
        // Only rotate if pointer lock is active or just allow free look
        cameraAngle -= e.movementX * 0.002;
        cameraVerticalAngle -= e.movementY * 0.002;
        cameraVerticalAngle = Math.max(
          0.1,
          Math.min(Math.PI / 2.2, cameraVerticalAngle)
        );
      });

      document.body.addEventListener("click", () => {
        document.body.requestPointerLock();
      });

      function init() {
        // Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x221133); // Dark synthwave sky
        scene.fog = new THREE.FogExp2(0x221133, 0.005);

        // Camera
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 0.8); // Sun/Moon
        dirLight.position.set(100, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        scene.add(dirLight);

        // Hemisphere Light for gradient feel
        const hemiLight = new THREE.HemisphereLight(0xff00de, 0x00d4ff, 0.4);
        scene.add(hemiLight);

        // --- GAME OBJECTS ---
        createCity();
        createPlayer();
        createTraffic();

        // Remove Loading Screen
        setTimeout(() => {
          document.getElementById("loading").style.opacity = 0;
          setTimeout(
            () => (document.getElementById("loading").style.display = "none"),
            500
          );
        }, 1000);

        // Start Loop
        animate();
      }

      // --- GENERATION FUNCTIONS ---

      function createCity() {
        // Ground
        const groundGeo = new THREE.PlaneGeometry(
          WORLD_SIZE * 2,
          WORLD_SIZE * 2
        );
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.8,
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Buildings
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const buildingMat = new THREE.MeshStandardMaterial({
          color: 0x222222,
          roughness: 0.2,
        });
        const windowMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // For lit windows texture sim

        city = []; // Store collision boxes

        for (let i = 0; i < BUILDING_COUNT; i++) {
          // Random sizes
          const w = 10 + Math.random() * 20;
          const d = 10 + Math.random() * 20;
          const h = 20 + Math.random() * 80; // Skyscrapers

          // Grid-ish placement
          let x = (Math.random() - 0.5) * WORLD_SIZE;
          let z = (Math.random() - 0.5) * WORLD_SIZE;

          // Snap to pseudo-grid to create "streets"
          x = Math.round(x / 40) * 40;
          z = Math.round(z / 40) * 40;

          if (Math.abs(x) < 20 && Math.abs(z) < 20) continue; // Keep center clear

          const building = new THREE.Mesh(
            boxGeo,
            new THREE.MeshStandardMaterial({
              color: new THREE.Color().setHSL(Math.random(), 0.5, 0.3),
              roughness: 0.1,
            })
          );

          building.position.set(x, h / 2, z);
          building.scale.set(w, h, d);
          building.castShadow = true;
          building.receiveShadow = true;
          scene.add(building);

          // Add collision data
          city.push({
            x: x,
            z: z,
            w: w,
            d: d,
            minX: x - w / 2,
            maxX: x + w / 2,
            minZ: z - d / 2,
            maxZ: z + d / 2,
          });

          // Add neon strips to some buildings
          if (Math.random() > 0.5) {
            const neon = new THREE.PointLight(
              Math.random() > 0.5 ? 0xff00de : 0x00d4ff,
              1,
              40
            );
            neon.position.set(x, 5, z + d / 2 + 1);
            scene.add(neon);
          }
        }

        // Trees
        for (let i = 0; i < 100; i++) {
          let x = (Math.random() - 0.5) * WORLD_SIZE;
          let z = (Math.random() - 0.5) * WORLD_SIZE;
          // Avoid buildings
          if (checkCollision(x, z)) continue;

          const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 6, 6);
          const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
          const trunk = new THREE.Mesh(trunkGeo, trunkMat);
          trunk.position.set(x, 3, z);

          const leavesGeo = new THREE.ConeGeometry(3, 6, 8);
          const leavesMat = new THREE.MeshStandardMaterial({ color: 0x00ff44 });
          const leaves = new THREE.Mesh(leavesGeo, leavesMat);
          leaves.position.y = 4;
          trunk.add(leaves);

          trunk.castShadow = true;
          scene.add(trunk);
        }
      }

      function createPlayer() {
        const group = new THREE.Group();

        // Torso
        const torso = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1.5, 0.6),
          new THREE.MeshStandardMaterial({ color: 0x00d4ff }) // Hawaiian shirt blue
        );
        torso.position.y = 2.25;
        torso.castShadow = true;
        group.add(torso);

        // Head
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 0.7, 0.6),
          new THREE.MeshStandardMaterial({ color: 0xffccaa })
        );
        head.position.y = 3.5;
        head.castShadow = true;
        group.add(head);

        // Legs (visual only, simple box)
        const legs = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, 1.5, 0.55),
          new THREE.MeshStandardMaterial({ color: 0x333333 }) // Jeans
        );
        legs.position.y = 0.75;
        legs.castShadow = true;
        group.add(legs);

        scene.add(group);

        player = {
          mesh: group,
          velocity: new THREE.Vector3(),
          speed: 10,
          rotation: 0,
          onGround: true,
          canEnterCar: false,
          targetCar: null,
        };
      }

      class Car {
        constructor(x, z, color) {
          this.mesh = new THREE.Group();

          // Chassis
          const chassis = new THREE.Mesh(
            new THREE.BoxGeometry(2.2, 1, 4.5),
            new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.3,
              metalness: 0.7,
            })
          );
          chassis.position.y = 1;
          chassis.castShadow = true;
          this.mesh.add(chassis);

          // Roof/Windshield
          const roof = new THREE.Mesh(
            new THREE.BoxGeometry(1.8, 0.8, 2.5),
            new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 })
          );
          roof.position.y = 1.9;
          roof.position.z = -0.2;
          this.mesh.add(roof);

          // Wheels
          const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
          wheelGeo.rotateZ(Math.PI / 2);
          const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

          const w1 = new THREE.Mesh(wheelGeo, wheelMat);
          w1.position.set(-1.2, 0.4, 1.5);
          const w2 = new THREE.Mesh(wheelGeo, wheelMat);
          w2.position.set(1.2, 0.4, 1.5);
          const w3 = new THREE.Mesh(wheelGeo, wheelMat);
          w3.position.set(-1.2, 0.4, -1.5);
          const w4 = new THREE.Mesh(wheelGeo, wheelMat);
          w4.position.set(1.2, 0.4, -1.5);
          this.mesh.add(w1, w2, w3, w4);

          // Headlights
          const hLight = new THREE.SpotLight(0xffffff, 2, 30, 0.5, 0.5, 1);
          hLight.position.set(0, 1, 2.5);
          hLight.target.position.set(0, 0, 10);
          this.mesh.add(hLight);
          this.mesh.add(hLight.target);

          this.mesh.position.set(x, 0, z);
          scene.add(this.mesh);

          // Physics properties
          this.speed = 0;
          this.steering = 0;
          this.rotation = Math.random() * Math.PI * 2;
          this.mesh.rotation.y = this.rotation;
          this.maxSpeed = 0.8;
          this.acceleration = 0.01;
          this.friction = 0.98;
        }

        update() {
          // Applied later in game loop
        }
      }

      function createTraffic() {
        const colors = [
          0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00de, 0xffffff, 0x000000,
        ];
        for (let i = 0; i < CAR_COUNT; i++) {
          let x = (Math.random() - 0.5) * (WORLD_SIZE * 0.8);
          let z = (Math.random() - 0.5) * (WORLD_SIZE * 0.8);
          // Simple avoid collision on spawn
          if (checkCollision(x, z)) {
            x += 10;
            z += 10;
          }

          cars.push(
            new Car(x, z, colors[Math.floor(Math.random() * colors.length)])
          );
        }
      }

      // --- LOGIC ---

      function checkCollision(x, z) {
        const pR = 1; // Player radius approx
        for (let b of city) {
          if (
            x > b.minX - pR &&
            x < b.maxX + pR &&
            z > b.minZ - pR &&
            z < b.maxZ + pR
          ) {
            return true;
          }
        }
        return false;
      }

      function resolveCollision(pos, prevPos) {
        if (checkCollision(pos.x, pos.z)) {
          // Very simple resolution: revert to previous valid position
          // In a real engine, we'd slide along the wall
          pos.x = prevPos.x;
          pos.z = prevPos.z;
          return true;
        }
        return false;
      }

      function handlePlayerMovement(delta) {
        const moveSpeed = keys["ShiftLeft"] ? 15 : 8;
        const turnSpeed = 3;

        // Input vector relative to camera
        let forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(
          new THREE.Vector3(0, 1, 0),
          cameraAngle
        );
        let right = new THREE.Vector3(1, 0, 0).applyAxisAngle(
          new THREE.Vector3(0, 1, 0),
          cameraAngle
        );

        let moveDir = new THREE.Vector3(0, 0, 0);

        if (keys["KeyW"]) moveDir.add(forward);
        if (keys["KeyS"]) moveDir.sub(forward);
        if (keys["KeyA"]) moveDir.sub(right);
        if (keys["KeyD"]) moveDir.add(right);

        // Gravity
        player.velocity.y -= 30 * delta;
        if (player.mesh.position.y <= 0) {
          player.velocity.y = 0;
          player.mesh.position.y = 0;
          player.onGround = true;
        }

        // Jump
        if (keys["Space"] && player.onGround) {
          player.velocity.y = 15;
          player.onGround = false;
        }

        // Apply Movement
        if (moveDir.length() > 0) {
          moveDir.normalize();
          // Smooth rotation to face movement direction
          const targetRotation = Math.atan2(moveDir.x, moveDir.z);
          // Simple lerp for rotation
          let rotDiff = targetRotation - player.rotation;
          // Normalize angle to -PI to PI
          while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
          while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
          player.rotation += rotDiff * 10 * delta;

          player.mesh.rotation.y = player.rotation;

          const prevPos = player.mesh.position.clone();
          player.mesh.position.x += moveDir.x * moveSpeed * delta;
          player.mesh.position.z += moveDir.z * moveSpeed * delta;

          resolveCollision(player.mesh.position, prevPos);
        }

        player.mesh.position.y += player.velocity.y * delta;

        // Check Car Proximity
        let closestDist = 5;
        let closestCar = null;

        cars.forEach((car) => {
          const d = player.mesh.position.distanceTo(car.mesh.position);
          if (d < closestDist) {
            closestDist = d;
            closestCar = car;
          }
        });

        if (closestCar) {
          document.getElementById("interaction-prompt").style.display = "block";
          if (keys["KeyF"]) {
            enterCar(closestCar);
            keys["KeyF"] = false; // Debounce
          }
        } else {
          document.getElementById("interaction-prompt").style.display = "none";
        }
      }

      function handleCarPhysics(car, delta, isPlayerControlled) {
        if (isPlayerControlled) {
          // Acceleration
          if (keys["KeyW"]) car.speed += car.acceleration;
          if (keys["KeyS"]) car.speed -= car.acceleration;
          if (keys["Space"]) car.speed *= 0.9; // Brake

          // Steering
          if (Math.abs(car.speed) > 0.01) {
            const turnFactor = Math.min(1.0, Math.abs(car.speed) * 2); // Turn slower when slow
            if (keys["KeyA"])
              car.rotation += 0.04 * (car.speed > 0 ? 1 : -1) * turnFactor;
            if (keys["KeyD"])
              car.rotation -= 0.04 * (car.speed > 0 ? 1 : -1) * turnFactor;
          }
        } else {
          // Simple traffic logic (go straight, turn randomly maybe? keeping it simple: just stop)
          car.speed *= 0.95;
        }

        // Friction
        car.speed *= car.friction;

        // Cap Speed
        car.speed = Math.max(
          Math.min(car.speed, car.maxSpeed),
          -car.maxSpeed / 2
        );

        // Apply Velocity
        const prevPos = car.mesh.position.clone();

        car.mesh.rotation.y = car.rotation;
        car.mesh.position.x +=
          Math.sin(car.rotation) * car.speed * 60 * delta * 20; // scaling speed
        car.mesh.position.z +=
          Math.cos(car.rotation) * car.speed * 60 * delta * 20;

        // World bounds
        if (Math.abs(car.mesh.position.x) > WORLD_SIZE)
          car.mesh.position.x *= -0.9;
        if (Math.abs(car.mesh.position.z) > WORLD_SIZE)
          car.mesh.position.z *= -0.9;

        // Building Collisions
        if (resolveCollision(car.mesh.position, prevPos)) {
          car.speed *= -0.5; // Bounce
        }
      }

      function enterCar(car) {
        gameState.mode = "driving";
        gameState.currentCar = car;
        player.mesh.visible = false;
        document.getElementById("interaction-prompt").style.display = "none";

        // Reset debounce
        setTimeout(() => (keys["KeyF"] = false), 500);
      }

      function exitCar() {
        if (!keys["KeyF"]) return;

        gameState.mode = "on_foot";
        player.mesh.visible = true;

        // Place player next to car
        const offset = new THREE.Vector3(2, 0, 0).applyAxisAngle(
          new THREE.Vector3(0, 1, 0),
          gameState.currentCar.rotation
        );
        player.mesh.position
          .copy(gameState.currentCar.mesh.position)
          .add(offset);
        player.mesh.position.y = 0; // Ensure on ground

        gameState.currentCar = null;
        keys["KeyF"] = false; // Debounce
      }

      function updateCamera() {
        let targetPos, targetRot;

        if (gameState.mode === "on_foot") {
          // Third Person Character
          targetPos = player.mesh.position.clone();
          targetPos.y += 2;
        } else {
          // Third Person Car
          targetPos = gameState.currentCar.mesh.position.clone();
          targetPos.y += 2.5;
        }

        // Calculate camera position based on orbit angles
        const dist = gameState.mode === "on_foot" ? 6 : 10;
        const offsetX =
          dist * Math.sin(cameraAngle) * Math.cos(cameraVerticalAngle);
        const offsetZ =
          dist * Math.cos(cameraAngle) * Math.cos(cameraVerticalAngle);
        const offsetY = dist * Math.sin(cameraVerticalAngle);

        const camPos = targetPos
          .clone()
          .add(new THREE.Vector3(offsetX, offsetY, offsetZ));

        // Smooth camera follow
        camera.position.lerp(camPos, 0.1);
        camera.lookAt(targetPos);
      }

      function animate() {
        requestAnimationFrame(animate);

        const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent huge jumps

        if (gameState.mode === "on_foot") {
          handlePlayerMovement(delta);
        } else {
          handleCarPhysics(gameState.currentCar, delta, true);
          if (keys["KeyF"]) exitCar();
        }

        // Update Traffic
        cars.forEach((c) => {
          if (c !== gameState.currentCar) handleCarPhysics(c, delta, false);
        });

        updateCamera();
        renderer.render(scene, camera);
      }

      // Handle Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      init();
    </script>
  </body>
</html>
