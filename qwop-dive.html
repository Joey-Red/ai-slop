<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QWOP High Diver</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #87ceeb;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.5);
        padding: 20px;
        border-radius: 10px;
        pointer-events: none;
        user-select: none;
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 24px;
        text-shadow: 2px 2px 0 #000;
      }
      p {
        margin: 5px 0;
        font-size: 14px;
      }
      .key {
        display: inline-block;
        background: #fff;
        color: #333;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
        font-family: monospace;
      }
      #score-board {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        display: none;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        border: 5px solid #ff0055;
      }
      #score-val {
        font-size: 48px;
        font-weight: bold;
        display: block;
        margin: 20px 0;
      }
      button {
        background: #ff0055;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
        pointer-events: all;
      }
      button:hover {
        background: #cc0044;
      }
      #controls-indicator {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .control-group {
        background: rgba(255, 255, 255, 0.1);
        padding: 5px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="ui-container">
      <h1>QWOP High Diver</h1>
      <p>You are wearing a speedo. You are very high up.</p>
      <div id="controls-indicator">
        <div class="control-group">
          <div><strong>Thighs</strong></div>
          <div><span class="key">Q</span> <span class="key">W</span></div>
        </div>
        <div class="control-group">
          <div><strong>Calves</strong></div>
          <div><span class="key">O</span> <span class="key">P</span></div>
        </div>
      </div>
      <p style="margin-top: 10px; font-style: italic">
        Shuffle to the edge and jump!
      </p>
    </div>

    <div id="score-board">
      <h2 id="judge-text">JUDGES SAY:</h2>
      <span id="score-val">0.0</span>
      <div id="commentary">Belly Flop!</div>
      <br />
      <button onclick="location.reload()">Dive Again</button>
    </div>

    <!-- Import Three.js and Cannon-es from module CDN -->
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
      import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

      // --- Configuration ---
      const CONFIG = {
        gravity: -9.82,
        platformHeight: 20,
        colors: {
          skin: 0xffccaa,
          speedo: 0xff0044, // Red Speedo
          platform: 0x555555,
          water: 0x00aaff,
          sky: 0x87ceeb,
        },
      };

      // --- Global Variables ---
      let scene, camera, renderer;
      let world;
      let clock;
      let mixer;
      let bodyParts = [];
      let constraints = [];
      let isGameOver = false;

      // Input State
      const input = {
        q: false,
        w: false,
        o: false,
        p: false,
      };

      // Physics Materials
      let skinMaterial, platformMaterial, slipperyMaterial;

      init();
      animate();

      function init() {
        // 1. Setup Three.js Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.sky);
        scene.fog = new THREE.Fog(CONFIG.colors.sky, 20, 100);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(10, CONFIG.platformHeight + 5, 10);
        camera.lookAt(0, CONFIG.platformHeight, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // 2. Setup Cannon.js World
        world = new CANNON.World();
        world.gravity.set(0, CONFIG.gravity, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Materials
        skinMaterial = new CANNON.Material("skin");
        platformMaterial = new CANNON.Material("platform");
        slipperyMaterial = new CANNON.Material("slippery");

        const skinPlatformContact = new CANNON.ContactMaterial(
          skinMaterial,
          platformMaterial,
          {
            friction: 0.5,
            restitution: 0.1,
          }
        );
        world.addContactMaterial(skinPlatformContact);

        // 3. Create Environment
        createPlatform();
        createPool();

        // 4. Create The Diver (Ragdoll)
        createDiver(0, CONFIG.platformHeight + 4, 0);

        // 5. Events
        window.addEventListener("resize", onWindowResize);
        window.addEventListener("keydown", (e) => handleKey(e, true));
        window.addEventListener("keyup", (e) => handleKey(e, false));

        clock = new THREE.Clock();
      }

      function handleKey(e, isDown) {
        const key = e.key.toLowerCase();
        if (input.hasOwnProperty(key)) {
          input[key] = isDown;
        }
      }

      function createPlatform() {
        // Visual
        const geo = new THREE.BoxGeometry(4, 1, 10);
        const mat = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.platform,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(0, CONFIG.platformHeight, 0);
        mesh.receiveShadow = true;
        scene.add(mesh);

        // Physics
        const shape = new CANNON.Box(new CANNON.Vec3(2, 0.5, 5));
        const body = new CANNON.Body({ mass: 0, material: platformMaterial });
        body.addShape(shape);
        body.position.set(0, CONFIG.platformHeight, 0);
        world.addBody(body);

        // Ladder/Rail visuals (just for looks)
        const railGeo = new THREE.CylinderGeometry(0.1, 0.1, 5);
        const railMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const railLeft = new THREE.Mesh(railGeo, railMat);
        railLeft.position.set(1.5, CONFIG.platformHeight + 2, -4);
        scene.add(railLeft);
      }

      function createPool() {
        // Water Surface Visual
        const waterGeo = new THREE.PlaneGeometry(100, 100);
        const waterMat = new THREE.MeshPhongMaterial({
          color: CONFIG.colors.water,
          transparent: true,
          opacity: 0.8,
          shininess: 100,
        });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0.5;
        scene.add(water);

        // Pool Bottom Visual
        const bottomGeo = new THREE.PlaneGeometry(100, 100);
        const bottomMat = new THREE.MeshStandardMaterial({ color: 0x004488 });
        const bottom = new THREE.Mesh(bottomGeo, bottomMat);
        bottom.rotation.x = -Math.PI / 2;
        bottom.position.y = -5;
        bottom.receiveShadow = true;
        scene.add(bottom);
      }

      // Helper to create a physics body and matching mesh
      function createPart(name, x, y, z, width, height, depth, mass, color) {
        // Three JS
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        scene.add(mesh);

        // Cannon JS
        const shape = new CANNON.Box(
          new CANNON.Vec3(width / 2, height / 2, depth / 2)
        );
        const body = new CANNON.Body({ mass: mass, material: skinMaterial });
        body.addShape(shape);
        body.position.set(x, y, z);
        body.linearDamping = 0.5; // Air resistance
        body.angularDamping = 0.5;
        world.addBody(body);

        const part = { mesh, body, name };
        bodyParts.push(part);
        return part;
      }

      function createDiver(x, y, z) {
        const density = 1;

        // Dimensions
        const torsoW = 0.6,
          torsoH = 0.8,
          torsoD = 0.3;
        const headSize = 0.3;
        const limbW = 0.25,
          limbH = 0.7,
          limbD = 0.25;

        // --- Create Body Parts ---

        // Head
        const head = createPart(
          "head",
          x,
          y + 1.2,
          z,
          headSize * 1.5,
          headSize * 1.5,
          headSize * 1.5,
          2,
          CONFIG.colors.skin
        );

        // Torso
        const torso = createPart(
          "torso",
          x,
          y + 0.4,
          z,
          torsoW,
          torsoH,
          torsoD,
          10,
          CONFIG.colors.skin
        );

        // Hips (The Speedo!)
        const hips = createPart(
          "hips",
          x,
          y - 0.2,
          z,
          torsoW,
          0.3,
          torsoD,
          5,
          CONFIG.colors.speedo
        );

        // Upper Legs
        const leftThigh = createPart(
          "leftThigh",
          x + 0.2,
          y - 0.7,
          z,
          limbW,
          limbH,
          limbD,
          3,
          CONFIG.colors.skin
        );
        const rightThigh = createPart(
          "rightThigh",
          x - 0.2,
          y - 0.7,
          z,
          limbW,
          limbH,
          limbD,
          3,
          CONFIG.colors.skin
        );

        // Lower Legs
        const leftCalf = createPart(
          "leftCalf",
          x + 0.2,
          y - 1.5,
          z,
          limbW,
          limbH,
          limbD,
          2,
          CONFIG.colors.skin
        );
        const rightCalf = createPart(
          "rightCalf",
          x - 0.2,
          y - 1.5,
          z,
          limbW,
          limbH,
          limbD,
          2,
          CONFIG.colors.skin
        );

        // Arms (Passive physics, just attached)
        const armW = 0.2,
          armH = 0.7,
          armD = 0.2;
        const leftArm = createPart(
          "leftArm",
          x + 0.5,
          y + 0.6,
          z,
          armW,
          armH,
          armD,
          1,
          CONFIG.colors.skin
        );
        const rightArm = createPart(
          "rightArm",
          x - 0.5,
          y + 0.6,
          z,
          armW,
          armH,
          armD,
          1,
          CONFIG.colors.skin
        );

        // --- Create Joints (Constraints) ---
        // Using ConeTwist or Hinge. Hinge is easier for QWOP style motors.

        // Neck
        addConstraint(
          torso,
          head,
          new CANNON.Vec3(0, torsoH / 2, 0),
          new CANNON.Vec3(0, -headSize, 0),
          Math.PI / 4
        );

        // Waist (Torso to Hips)
        addConstraint(
          torso,
          hips,
          new CANNON.Vec3(0, -torsoH / 2, 0),
          new CANNON.Vec3(0, 0.15, 0),
          Math.PI / 8
        );

        // Shoulders
        addConstraint(
          torso,
          leftArm,
          new CANNON.Vec3(torsoW / 2, 0.3, 0),
          new CANNON.Vec3(-armW / 2, 0.3, 0),
          Math.PI,
          [0, 0, 1]
        );
        addConstraint(
          torso,
          rightArm,
          new CANNON.Vec3(-torsoW / 2, 0.3, 0),
          new CANNON.Vec3(armW / 2, 0.3, 0),
          Math.PI,
          [0, 0, 1]
        );

        // Hips (Thighs) - CONTROLLED
        // Axis [1, 0, 0] means rotation around X axis (forward/back flip motion)
        const leftHipJoint = addHinge(
          hips,
          leftThigh,
          new CANNON.Vec3(0.15, -0.15, 0),
          new CANNON.Vec3(0, limbH / 2, 0),
          [1, 0, 0]
        );
        const rightHipJoint = addHinge(
          hips,
          rightThigh,
          new CANNON.Vec3(-0.15, -0.15, 0),
          new CANNON.Vec3(0, limbH / 2, 0),
          [1, 0, 0]
        );

        // Knees (Calves) - CONTROLLED
        const leftKneeJoint = addHinge(
          leftThigh,
          leftCalf,
          new CANNON.Vec3(0, -limbH / 2, 0),
          new CANNON.Vec3(0, limbH / 2, 0),
          [1, 0, 0]
        );
        const rightKneeJoint = addHinge(
          rightThigh,
          rightCalf,
          new CANNON.Vec3(0, -limbH / 2, 0),
          new CANNON.Vec3(0, limbH / 2, 0),
          [1, 0, 0]
        );

        // Store motorized joints for input handling
        constraints = {
          leftHip: leftHipJoint,
          rightHip: rightHipJoint,
          leftKnee: leftKneeJoint,
          rightKnee: rightKneeJoint,
        };

        // Enable motors
        for (let key in constraints) {
          constraints[key].enableMotor();
          constraints[key].setMotorSpeed(0);
          constraints[key].collideConnected = false;
        }
      }

      function addConstraint(partA, partB, pivotA, pivotB, angleLimit) {
        const c = new CANNON.ConeTwistConstraint(partA.body, partB.body, {
          pivotA: pivotA,
          pivotB: pivotB,
          axisA: CANNON.Vec3.UNIT_Y,
          axisB: CANNON.Vec3.UNIT_Y,
          angle: angleLimit,
          twistAngle: 0,
        });
        world.addConstraint(c);
        return c;
      }

      function addHinge(partA, partB, pivotA, pivotB, axis) {
        const c = new CANNON.HingeConstraint(partA.body, partB.body, {
          pivotA: pivotA,
          pivotB: pivotB,
          axisA: new CANNON.Vec3(...axis),
          axisB: new CANNON.Vec3(...axis),
        });
        world.addConstraint(c);
        return c;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        if (isGameOver) return;

        const dt = clock.getDelta();

        // --- Game Logic ---

        // Apply Motors based on QWOP Input
        const motorSpeed = 8;
        const maxForce = 100; // Torque limit

        // Q/W controls Hips (Thighs)
        if (input.q) {
          constraints.leftHip.enableMotor();
          constraints.leftHip.setMotorSpeed(motorSpeed);
          constraints.rightHip.setMotorSpeed(-motorSpeed); // Alternating kick
        } else if (input.w) {
          constraints.leftHip.enableMotor();
          constraints.leftHip.setMotorSpeed(-motorSpeed);
          constraints.rightHip.setMotorSpeed(motorSpeed);
        } else {
          // Damping when released
          constraints.leftHip.setMotorSpeed(0);
          constraints.rightHip.setMotorSpeed(0);
        }

        // O/P controls Knees
        if (input.o) {
          constraints.leftKnee.enableMotor();
          constraints.leftKnee.setMotorSpeed(motorSpeed);
          constraints.rightKnee.setMotorSpeed(-motorSpeed);
        } else if (input.p) {
          constraints.leftKnee.enableMotor();
          constraints.leftKnee.setMotorSpeed(-motorSpeed);
          constraints.rightKnee.setMotorSpeed(motorSpeed);
        } else {
          constraints.leftKnee.setMotorSpeed(0);
          constraints.rightKnee.setMotorSpeed(0);
        }

        // --- Physics Step ---
        world.step(1 / 60, dt, 3);

        // --- Sync Visuals ---
        // Find the hips to track camera
        let hipPos = new THREE.Vector3();

        bodyParts.forEach((part) => {
          part.mesh.position.copy(part.body.position);
          part.mesh.quaternion.copy(part.body.quaternion);
          if (part.name === "hips") {
            hipPos.copy(part.mesh.position);
          }
        });

        // Camera Follow
        // Smooth lerp
        const targetCamY = Math.max(1, hipPos.y); // Don't go below water
        camera.position.y += (targetCamY + 2 - camera.position.y) * 0.1;
        camera.lookAt(0, Math.max(0, hipPos.y - 2), 0);

        // --- Win/Lose Condition ---
        checkWaterEntry(hipPos);

        renderer.render(scene, camera);
      }

      function checkWaterEntry(hipPos) {
        if (hipPos.y < 1) {
          isGameOver = true;
          calculateScore();
        }
      }

      function calculateScore() {
        // Find Torso
        const torso = bodyParts.find((p) => p.name === "torso");

        // Get rotation relative to World Up (Y axis)
        // Transform local Y vector (head-to-waist) to world space
        const localUp = new CANNON.Vec3(0, 1, 0);
        const worldOrientation = torso.body.quaternion;
        const torsoUp = new CANNON.Vec3();
        worldOrientation.vmult(localUp, torsoUp);

        // Calculate dot product with world Up (0, 1, 0)
        // 1 = perfectly upright, -1 = perfectly upside down (also good for diving), 0 = flat belly flop
        const dot = torsoUp.dot(new CANNON.Vec3(0, 1, 0));
        const entryAngle = Math.abs(Math.abs(dot)); // 0 to 1 magnitude of verticality

        let score = (entryAngle * 10).toFixed(1);
        let comment = "";

        if (score > 9.0) comment = "OLYMPIC GOLD! (Perfect Vertical)";
        else if (score > 7.0) comment = "Great Entry!";
        else if (score > 4.0) comment = "Sloppy...";
        else comment = "OUCH! BELLY FLOP!";

        document.getElementById("score-board").style.display = "block";
        document.getElementById("score-val").innerText = score;
        document.getElementById("commentary").innerText = comment;
        document.getElementById("commentary").style.color =
          score > 5 ? "green" : "red";
      }
    </script>
  </body>
</html>
