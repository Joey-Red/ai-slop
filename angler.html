<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Deep Angler</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Courier New", Courier, monospace;
        user-select: none;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #00ffff;
        text-shadow: 0 0 10px #00ffff;
        pointer-events: none;
        z-index: 10;
      }
      #score {
        font-size: 24px;
        font-weight: bold;
      }
      #dist {
        font-size: 14px;
        opacity: 0.7;
      }
      #game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff4444;
        font-size: 40px;
        font-weight: bold;
        text-align: center;
        display: none;
        text-shadow: 0 0 20px #ff0000;
        z-index: 20;
        background: rgba(0, 0, 0, 0.8);
        padding: 40px;
        border: 2px solid #ff4444;
        border-radius: 10px;
      }
      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 5, 10, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #00ffff;
        z-index: 30;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 10px;
        text-shadow: 0 0 20px #00ffff;
      }
      p {
        font-size: 18px;
        max-width: 600px;
        text-align: center;
        line-height: 1.5;
      }
      button {
        margin-top: 30px;
        padding: 15px 40px;
        font-size: 20px;
        background: transparent;
        color: #00ffff;
        border: 2px solid #00ffff;
        cursor: pointer;
        font-family: inherit;
        transition: 0.3s;
        text-transform: uppercase;
        letter-spacing: 2px;
      }
      button:hover {
        background: #00ffff;
        color: #000;
        box-shadow: 0 0 30px #00ffff;
      }
    </style>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="ui">
      <div id="score">DEPTH: 0m</div>
    </div>

    <div id="start-screen">
      <h1>ABYSSAL DRIFT</h1>
      <p>
        You are an anglerfish in the deep void.<br />Use your lure to light the
        path.<br />Avoid the cave walls and rock spikes.
      </p>
      <p style="color: #aaa; font-size: 14px; margin-top: 20px">
        [Mouse to Steer]
      </p>
      <button id="start-btn">ENTER THE DARK</button>
    </div>

    <div id="game-over">
      CRUSHED<br />
      <span
        style="font-size: 20px; color: white; display: block; margin-top: 20px"
        >Click to Restart</span
      >
    </div>

    <!-- Import Three.js -->
    <script type="module">
      import * as THREE from "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js";

      // --- Configuration ---
      const TUBE_SEGMENTS = 500;
      const TUBE_RADIUS = 4;
      const CAMERA_SPEED = 0.0004;
      const MOUSE_SENSITIVITY = 0.08;

      // --- Globals ---
      let scene, camera, renderer;
      let tunnelMesh, tubeGeometry, curve;
      let playerGroup, fishMesh, jawMesh, lureLight, lureBulb;
      let obstacles = [];
      let particles;
      let gameActive = false;
      let distanceTraveled = 0;
      let loopProgress = 0;

      // Mouse Input
      let targetX = 0;
      let targetY = 0;
      let mouseX = 0;
      let mouseY = 0;

      const uiScore = document.getElementById("score");
      const gameOverScreen = document.getElementById("game-over");
      const startScreen = document.getElementById("start-screen");
      const startBtn = document.getElementById("start-btn");

      init();
      animate();

      function init() {
        // 1. Scene Setup
        scene = new THREE.Scene();
        // Deep dark blue fog for underwater atmosphere
        scene.fog = new THREE.FogExp2(0x000510, 0.08);
        scene.background = new THREE.Color(0x000000);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(
          65,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        document.body.appendChild(renderer.domElement);

        // 4. Generate Cave Tunnel
        generateTunnel();

        // 5. Generate Player (Anglerfish)
        createPlayer();

        // 6. Ambient Particles (Marine Snow)
        createMarineSnow();

        // 7. Listeners
        document.addEventListener("mousemove", onMouseMove);
        window.addEventListener("resize", onWindowResize);
        startBtn.addEventListener("click", startGame);
        gameOverScreen.addEventListener("click", resetGame);
      }

      function generateTunnel() {
        // Create a winding path
        const points = [];
        const count = 60;
        for (let i = 0; i < count; i++) {
          points.push(
            new THREE.Vector3(
              Math.sin(i * 0.5) * 15 + (Math.random() - 0.5) * 10,
              Math.cos(i * 0.3) * 15 + (Math.random() - 0.5) * 10,
              i * -20 // Move forward in -Z
            )
          );
        }
        curve = new THREE.CatmullRomCurve3(points);
        curve.closed = false;

        // Create the tube geometry
        tubeGeometry = new THREE.TubeGeometry(
          curve,
          TUBE_SEGMENTS,
          TUBE_RADIUS,
          12,
          false
        );

        // Dark, rocky material
        const material = new THREE.MeshStandardMaterial({
          color: 0x222222,
          roughness: 0.9,
          metalness: 0.1,
          side: THREE.BackSide, // Render inside of tube
          flatShading: true,
        });

        tunnelMesh = new THREE.Mesh(tubeGeometry, material);
        scene.add(tunnelMesh);

        // Add Obstacles (Stalagmites/Rocks) inside the tunnel
        const obsGeo = new THREE.DodecahedronGeometry(1, 0);
        const obsMat = new THREE.MeshStandardMaterial({
          color: 0x111111,
          roughness: 1,
          flatShading: true,
        });

        for (let i = 20; i < TUBE_SEGMENTS - 20; i += 5) {
          if (Math.random() > 0.4) {
            // 60% chance of obstacle
            const obstacle = new THREE.Mesh(obsGeo, obsMat);

            // Get position along curve
            const t = i / TUBE_SEGMENTS;
            const pos = curve.getPointAt(t);
            const tangent = curve.getTangentAt(t).normalize();

            // Randomize position around the center line (on the walls)
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 2 + 1; // Distance from center

            // Calculate offset vector
            const normal = new THREE.Vector3(1, 0, 0).applyAxisAngle(
              tangent,
              angle
            );
            pos.add(normal.multiplyScalar(radius));

            obstacle.position.copy(pos);

            // Random scaling
            const s = Math.random() * 1.5 + 0.5;
            obstacle.scale.set(s, s, s);

            // Random Rotation
            obstacle.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              0
            );

            scene.add(obstacle);
            obstacles.push(obstacle);
          }
        }
      }

      function createPlayer() {
        playerGroup = new THREE.Group();

        // Fish Material
        const skinMat = new THREE.MeshStandardMaterial({
          color: 0x2a2a35,
          roughness: 0.7,
          flatShading: true,
        });

        // Body
        const bodyGeo = new THREE.DodecahedronGeometry(0.8, 1);
        bodyGeo.scale(1, 0.8, 1.5);
        fishMesh = new THREE.Mesh(bodyGeo, skinMat);
        playerGroup.add(fishMesh);

        // Jaw
        const jawGeo = new THREE.BoxGeometry(1, 0.3, 1.2);
        jawMesh = new THREE.Mesh(jawGeo, skinMat);
        jawMesh.position.set(0, -0.5, 0.2);
        playerGroup.add(jawMesh);

        // Teeth
        const toothGeo = new THREE.ConeGeometry(0.05, 0.2, 4);
        const toothMat = new THREE.MeshBasicMaterial({ color: 0xdddddd });
        for (let i = 0; i < 6; i++) {
          const t = new THREE.Mesh(toothGeo, toothMat);
          t.position.set((i - 2.5) * 0.3, -0.3, 0.8);
          t.rotation.x = Math.PI;
          playerGroup.add(t);

          // Bottom teeth
          const t2 = new THREE.Mesh(toothGeo, toothMat);
          t2.position.set((i - 2.5) * 0.3, -0.35, 0.8);
          jawMesh.add(t2); // attached to jaw
        }

        // The Lure Stem
        const lureStemGeo = new THREE.CylinderGeometry(0.02, 0.05, 1.5, 4);
        lureStemGeo.translate(0, 0.75, 0);
        lureStemGeo.rotateX(Math.PI / 3);
        const lureStem = new THREE.Mesh(lureStemGeo, skinMat);
        lureStem.position.set(0, 0.5, 0.2);
        playerGroup.add(lureStem);

        // The Bulb (Light Source visual)
        const bulbGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const bulbMat = new THREE.MeshBasicMaterial({ color: 0xccffff });
        lureBulb = new THREE.Mesh(bulbGeo, bulbMat);
        // Position at tip of stem (approximated by rotation math)
        lureBulb.position.set(0, 1.2, 1.5);
        playerGroup.add(lureBulb);

        // Actual Light Source
        lureLight = new THREE.PointLight(0x00ffff, 3, 25); // Cyan light, intensity 3, distance 25
        lureLight.position.copy(lureBulb.position);
        playerGroup.add(lureLight);

        // SpotLight facing forward (Flashlight effect)
        const spotLight = new THREE.SpotLight(0xffffff, 2);
        spotLight.position.set(0, 1, 1);
        spotLight.target.position.set(0, 0, 10);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.distance = 40;
        playerGroup.add(spotLight);
        playerGroup.add(spotLight.target);

        // Eyes (Spooky glowing dots)
        const eyeGeo = new THREE.SphereGeometry(0.1, 4, 4);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(0.5, 0.2, 0.5);
        rightEye.position.set(-0.5, 0.2, 0.5);
        playerGroup.add(leftEye);
        playerGroup.add(rightEye);

        scene.add(playerGroup);
      }

      function createMarineSnow() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        for (let i = 0; i < 2000; i++) {
          vertices.push(
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 200 - 50
          );
        }
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(vertices, 3)
        );
        const material = new THREE.PointsMaterial({
          color: 0x88aacc,
          size: 0.1,
          transparent: true,
          opacity: 0.6,
        });
        particles = new THREE.Points(geometry, material);
        scene.add(particles);
      }

      function startGame() {
        startScreen.style.display = "none";
        gameActive = true;
      }

      function resetGame() {
        // Reload page for simplicity in single file logic
        location.reload();
      }

      function onMouseMove(event) {
        if (!gameActive) return;
        // Normalize mouse pos -1 to 1
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function checkCollision(playerPos) {
        // Simple distance check against all obstacles
        // Optimized: only check obstacles roughly near the player loop progress?
        // For this demo, brute force is okay for < 100 obstacles

        // Tube wall collision logic (approximate)
        // Since player is centered on curve, large X/Y offsets mean hitting wall
        if (Math.abs(targetX) > 2.8 || Math.abs(targetY) > 2.8) {
          return true;
        }

        // Rock collision
        for (let ob of obstacles) {
          const dist = playerPos.distanceTo(ob.position);
          if (dist < 1.5) {
            // 1.5 = radius of rock + radius of fish approx
            return true;
          }
        }
        return false;
      }

      function animate() {
        requestAnimationFrame(animate);

        if (!gameActive) {
          // Idle animation
          if (playerGroup) playerGroup.rotation.y += 0.01;
          renderer.render(scene, camera);
          return;
        }

        // 1. Move Player along Curve
        loopProgress += CAMERA_SPEED;
        distanceTraveled += 1;
        uiScore.innerText = `DEPTH: ${Math.floor(distanceTraveled / 10)}m`;

        if (loopProgress > 0.98) {
          // Win or Loop? Let's just win/end for this demo
          uiScore.innerText = "THE DEPTHS CLAIMED YOU (End of Tunnel)";
          gameActive = false;
          setTimeout(resetGame, 3000);
        }

        // Get position on curve
        const p1 = curve.getPointAt(loopProgress);
        const p2 = curve.getPointAt(loopProgress + 0.001); // point slightly ahead for rotation

        // Move Player Group to curve position
        playerGroup.position.copy(p1);
        playerGroup.lookAt(p2);

        // 2. Handle Local Movement (Steering)
        // Lerp target values for smoothness
        targetX += (mouseX * 3 - targetX) * MOUSE_SENSITIVITY;
        targetY += (mouseY * 3 - targetY) * MOUSE_SENSITIVITY;

        // Create a coordinate system local to the curve
        // We use the 'up' vector and the 'tangent' (forward) to find 'right'
        const tangent = new THREE.Vector3().subVectors(p2, p1).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
        const trueUp = new THREE.Vector3()
          .crossVectors(right, tangent)
          .normalize();

        // Apply offsets to player global position
        const offset = new THREE.Vector3();
        offset.addScaledVector(right, -targetX); // Invert X for natural feel
        offset.addScaledVector(trueUp, targetY);

        playerGroup.position.add(offset);

        // Fish Banking/Tilting animation based on movement
        fishMesh.rotation.z = targetX * 0.5;
        fishMesh.rotation.x = -targetY * 0.3;

        // Bobbing Lure
        lureBulb.position.y = 1.2 + Math.sin(Date.now() * 0.005) * 0.1;
        lureLight.position.y = lureBulb.position.y;
        lureLight.intensity = 2 + Math.sin(Date.now() * 0.02) * 0.5; // flicker

        // 3. Camera Follow
        // Camera sits behind the player, oriented to path
        const camPos = curve.getPointAt(Math.max(0, loopProgress - 0.02));
        camera.position.copy(camPos);
        camera.lookAt(playerGroup.position);
        // Add slight lag/offset to camera for dynamic feel
        camera.position.y += 0.5;

        // 4. Move Particles (create illusion of speed)
        if (particles) {
          particles.position.z = playerGroup.position.z;
          // Wiggle particles
          particles.rotation.z += 0.001;
        }

        // 5. Collision Detection
        if (checkCollision(playerGroup.position)) {
          gameActive = false;
          gameOverScreen.style.display = "block";
          // Red flash
          scene.fog.color.setHex(0x550000);
          lureLight.color.setHex(0xff0000);
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
