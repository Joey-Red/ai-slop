<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hydro Tycoon - Stay Hydrated</title>
    <style>
      :root {
        --primary: #3498db;
        --dark: #2c3e50;
        --light: #ecf0f1;
        --accent: #00d2d3;
      }
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #1a1a2e;
        color: white;
        user-select: none;
      }
      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        pointer-events: none; /* Let clicks pass through to 3D canvas where empty */
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* Header Stats */
      .header {
        text-align: center;
        padding: 20px;
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
        pointer-events: auto;
      }
      h1 {
        margin: 0;
        font-size: 1.5rem;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 2px;
      }
      .water-count {
        font-size: 3rem;
        font-weight: bold;
        text-shadow: 0 0 10px var(--primary);
      }
      .rate-display {
        font-size: 1.2rem;
        color: #a8e6cf;
      }

      /* Floating Text (Click feedback) */
      .floating-text {
        position: absolute;
        color: white;
        font-weight: bold;
        font-size: 1.5rem;
        pointer-events: none;
        animation: floatUp 1s ease-out forwards;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        white-space: nowrap; /* Keep text on one line */
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(-50px) scale(1.5);
        }
      }

      /* Upgrade Panel */
      .upgrade-panel {
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        width: 100%;
        max-width: 400px;
        height: 40%; /* Bottom section */
        pointer-events: auto;
        overflow-y: auto;
        border-top: 2px solid var(--primary);
        padding: 10px;
        box-sizing: border-box;
        align-self: center;
      }

      @media (min-width: 768px) {
        .upgrade-panel {
          position: absolute;
          right: 0;
          top: 0;
          height: 100%;
          width: 350px;
          border-top: none;
          border-left: 2px solid var(--primary);
        }
        #ui-layer {
          flex-direction: row;
        }
        .header {
          position: absolute;
          width: calc(100% - 350px);
          pointer-events: none;
        }
      }

      .panel-title {
        font-size: 1.2rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 5px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .upgrade-item {
        background: rgba(255, 255, 255, 0.1);
        margin-bottom: 8px;
        padding: 10px;
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px solid transparent;
      }
      .upgrade-item:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateX(-5px);
      }
      .upgrade-item.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        filter: grayscale(1);
      }
      .upgrade-info h3 {
        margin: 0;
        font-size: 1rem;
      }
      .upgrade-info p {
        margin: 0;
        font-size: 0.8rem;
        color: #aaa;
      }
      .upgrade-cost {
        text-align: right;
        font-weight: bold;
        color: var(--accent);
      }
      .upgrade-count {
        background: var(--primary);
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.8rem;
        margin-left: 5px;
      }

      /* Save Notification */
      #save-notify {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(46, 204, 113, 0.8);
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        opacity: 0;
        transition: opacity 0.5s;
        pointer-events: none;
      }

      /* Buttons */
      .btn-group {
        display: flex;
        gap: 5px;
      }
      .btn {
        background: #e74c3c;
        border: none;
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
      }
      .btn:hover {
        background: #c0392b;
      }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Three.js Post-Processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="canvas-container"></div>

    <div id="ui-layer">
      <div class="header">
        <h1>Hydro Tycoon</h1>
        <div class="water-count"><span id="liters">0</span> L</div>
        <div class="rate-display"><span id="mps">0.0</span> Liters/sec</div>
      </div>

      <div class="upgrade-panel">
        <div class="panel-title">
          <span>Hydration Source</span>
          <div class="btn-group">
            <button class="btn" onclick="resetGame()">Reset</button>
          </div>
        </div>
        <div id="upgrades-list">
          <!-- Upgrades injected here -->
        </div>
      </div>

      <div id="save-notify">Game Saved</div>
    </div>

    <script>
      // --- Game State & Logic ---

      const defaultState = {
        liters: 0,
        totalLiters: 0, // Lifetime earnings
        clickPower: 1,
        totalUpgrades: 0, // Keep track of total upgrades for visual progression
        startTime: Date.now(),
        upgrades: {
          sip: {
            name: "Tiny Sip",
            baseCost: 15,
            count: 0,
            rate: 0.5,
            desc: "A small sip to keep going.",
          },
          ice: {
            name: "Ice Cube",
            baseCost: 100,
            count: 0,
            rate: 3,
            desc: "Cool and refreshing.",
          },
          bottle: {
            name: "Plastic Bottle",
            baseCost: 1100,
            count: 0,
            rate: 12,
            desc: "Standard hydration unit.",
          },
          fountain: {
            name: "Water Fountain",
            baseCost: 12000,
            count: 0,
            rate: 55,
            desc: "Public hydration access.",
          },
          cooler: {
            name: "Office Cooler",
            baseCost: 130000,
            count: 0,
            rate: 320,
            desc: "Water cooler chat included.",
          },
          truck: {
            name: "Tanker Truck",
            baseCost: 1400000,
            count: 0,
            rate: 1500,
            desc: "Delivering massive hydration.",
          },
          cloud: {
            name: "Rain Cloud",
            baseCost: 20000000,
            count: 0,
            rate: 8000,
            desc: "Nature's delivery system.",
          },
          glacier: {
            name: "Ancient Glacier",
            baseCost: 330000000,
            count: 0,
            rate: 45000,
            desc: "Purest water on earth.",
          },
        },
      };

      let game = JSON.parse(JSON.stringify(defaultState)); // Deep copy
      let autoSaveInterval;
      let upgradeElements = {}; // Store references to DOM elements

      // --- Save System ---

      function loadGame() {
        const saved = localStorage.getItem("hydroTycoonSave");
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            // Merge with default to handle new updates/fields
            game = {
              ...defaultState,
              ...parsed,
              upgrades: { ...defaultState.upgrades },
            };

            // Specifically merge upgrades to keep counts but get new stats if changed
            for (const key in parsed.upgrades) {
              if (game.upgrades[key]) {
                game.upgrades[key].count = parsed.upgrades[key].count;
              }
            }
            // Recalculate total upgrades (important for visuals)
            game.totalUpgrades = Object.values(game.upgrades).reduce(
              (sum, u) => sum + u.count,
              0
            );

            // Calculate offline progress
            const now = Date.now();
            if (parsed.lastSaveTime) {
              const diffSeconds = (now - parsed.lastSaveTime) / 1000;
              const offlineGains = calculateMPS() * diffSeconds;
              if (offlineGains > 0) {
                game.liters += offlineGains;
                game.totalLiters += offlineGains;
                console.log(
                  `Offline for ${diffSeconds.toFixed(
                    1
                  )}s. Gained ${offlineGains.toFixed(1)}L`
                );
              }
            }
          } catch (e) {
            console.error("Save file corrupted", e);
          }
        }
        // Initialize the list once
        initUpgradeList();
        // Then update numbers and visuals
        updateUI();
        // We will updateVisuals after ThreeJS initializes
      }

      function saveGame(showNotify = false) {
        game.lastSaveTime = Date.now();
        localStorage.setItem("hydroTycoonSave", JSON.stringify(game));

        if (showNotify) {
          const el = document.getElementById("save-notify");
          el.style.opacity = "1";
          setTimeout(() => {
            el.style.opacity = "0";
          }, 2000);
        }
      }

      function resetGame() {
        if (confirm("Are you sure you want to reset all progress?")) {
          localStorage.removeItem("hydroTycoonSave");
          // Manually reset state variables
          game = JSON.parse(JSON.stringify(defaultState));
          game.startTime = Date.now();

          // Re-initialize the upgrade list UI with zero counts
          initUpgradeList();
          updateUI();

          // Reset visuals
          currentVisualTier = -1; // Force update
          updateVisuals();

          // Save the reset state immediately
          saveGame(true);
        }
      }

      // --- Core Calculations ---

      function calculateMPS() {
        let mps = 0;
        for (const key in game.upgrades) {
          mps += game.upgrades[key].count * game.upgrades[key].rate;
        }
        return mps;
      }

      function getCost(key) {
        const item = game.upgrades[key];
        return Math.floor(item.baseCost * Math.pow(1.15, item.count));
      }

      function buyUpgrade(key) {
        const cost = getCost(key);
        if (game.liters >= cost) {
          game.liters -= cost;
          game.upgrades[key].count++;
          game.totalUpgrades++; // Increment total upgrades

          saveGame();
          updateVisuals(); // Update visuals immediately after buying
        }
      }

      function addWater(amount) {
        game.liters += amount;
        game.totalLiters += amount;
      }

      // --- UI Updates ---

      function initUpgradeList() {
        const list = document.getElementById("upgrades-list");
        list.innerHTML = "";
        upgradeElements = {};

        for (const key in game.upgrades) {
          const item = game.upgrades[key];

          const div = document.createElement("div");
          div.className = "upgrade-item";
          // Check affordability dynamically inside click handler
          div.onclick = () => buyUpgrade(key);

          div.innerHTML = `
                    <div class="upgrade-info">
                        <h3>${item.name} <span class="upgrade-count" id="count-${key}">0</span></h3>
                        <p>${item.desc} (+${item.rate}/s)</p>
                    </div>
                    <div class="upgrade-cost" id="cost-${key}">0 L</div>
                `;
          list.appendChild(div);

          // Store references to update later without rebuilding DOM
          upgradeElements[key] = {
            el: div,
            countSpan: div.querySelector(`#count-${key}`),
            costDiv: div.querySelector(`#cost-${key}`),
          };
        }
      }

      function updateUI() {
        document.getElementById("liters").innerText = Math.floor(
          game.liters
        ).toLocaleString();
        document.getElementById("mps").innerText = calculateMPS()
          .toFixed(1)
          .toLocaleString();

        // Update existing elements instead of rebuilding
        for (const key in game.upgrades) {
          if (!upgradeElements[key]) continue;

          const item = game.upgrades[key];
          const cost = getCost(key);
          const canAfford = game.liters >= cost;
          const ui = upgradeElements[key];

          // Toggle disabled class
          if (canAfford) {
            ui.el.classList.remove("disabled");
          } else {
            ui.el.classList.add("disabled");
          }

          // Update text content
          ui.countSpan.innerText = item.count;
          ui.costDiv.innerText = cost.toLocaleString() + " L";
        }
      }

      function spawnFloatingText(x, y, text) {
        const el = document.createElement("div");
        el.className = "floating-text";
        el.innerText = `+${text.toFixed(0)} L`;
        el.style.left = x + "px";
        el.style.top = y + "px";
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
      }

      // --- Three.js Setup ---

      let scene, camera, renderer, composer;
      let bottleGroup, bottleMesh, waterMesh, capMesh, labelMesh, dropMesh;
      let bubbles = [];
      let raycaster, mouse;
      let bloomPass;

      // Visual tiers configuration
      const visualTiers = [
        {
          totalUpgrades: 0,
          bgColor: 0x1a1a2e,
          fogColor: 0x1a1a2e,
          fogDensity: 0.03,
          bloomStrength: 0.5,
          bottleType: 0,
        }, // Initial
        {
          totalUpgrades: 5,
          bgColor: 0x2e4a6e,
          fogColor: 0x2e4a6e,
          fogDensity: 0.025,
          bloomStrength: 0.8,
          bottleType: 1,
        }, // Tier 1
        {
          totalUpgrades: 20,
          bgColor: 0x4a6e8e,
          fogColor: 0x4a6e8e,
          fogDensity: 0.02,
          bloomStrength: 1.2,
          bottleType: 2,
        }, // Tier 2
        {
          totalUpgrades: 50,
          bgColor: 0x6a9ecf,
          fogColor: 0x6a9ecf,
          fogDensity: 0.015,
          bloomStrength: 1.8,
          bottleType: 3,
        }, // Tier 3
        {
          totalUpgrades: 100,
          bgColor: 0x8ecaff,
          fogColor: 0x8ecaff,
          fogDensity: 0.01,
          bloomStrength: 2.5,
          bottleType: 4,
        }, // Tier 4
      ];
      let currentVisualTier = -1;

      function initThree() {
        const container = document.getElementById("canvas-container");

        // Scene
        scene = new THREE.Scene();
        // Default bg
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.03);

        // Camera
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Post-processing (Bloom Effect)
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5, // strength
          0.4, // radius
          0.85 // threshold
        );
        composer.addPass(bloomPass);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0x3498db, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0x00d2d3, 0.5);
        pointLight.position.set(-5, 2, -5);
        scene.add(pointLight);

        // Objects
        bottleGroup = new THREE.Group();
        scene.add(bottleGroup);

        createParticles();

        // Interaction
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Event Listeners
        window.addEventListener("resize", onWindowResize, false);

        const handleInput = (event) => {
          let clientX, clientY;

          if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
          } else {
            clientX = event.clientX;
            clientY = event.clientY;
          }

          mouse.x = (clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(clientY / window.innerHeight) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          const intersects = raycaster.intersectObjects(bottleGroup.children);

          if (intersects.length > 0) {
            handleBottleClick(clientX, clientY);
          }
        };

        window.addEventListener("mousedown", handleInput);
        window.addEventListener("touchstart", handleInput, { passive: true });

        // Init visuals after scene is ready
        updateVisuals();
        animate();
      }

      function updateVisuals() {
        if (!scene) return;

        // Find the highest tier we have unlocked
        let targetTierIndex = 0;
        for (let i = 0; i < visualTiers.length; i++) {
          if (game.totalUpgrades >= visualTiers[i].totalUpgrades) {
            targetTierIndex = i;
          }
        }

        if (currentVisualTier !== targetTierIndex) {
          currentVisualTier = targetTierIndex;
          const settings = visualTiers[currentVisualTier];

          changeSceneColors(settings);
          evolveBottle(settings.bottleType);
        }
      }

      function changeSceneColors(settings) {
        // Animate color changes for smoothness would be nice, but immediate swap is okay for now
        scene.background = new THREE.Color(settings.bgColor);
        scene.fog.color = new THREE.Color(settings.fogColor);
        scene.fog.density = settings.fogDensity;
        bloomPass.strength = settings.bloomStrength;
      }

      function evolveBottle(tier) {
        // Remove previous bottle components
        while (bottleGroup.children.length > 0) {
          bottleGroup.remove(bottleGroup.children[0]);
        }

        let bottleBodyGeo,
          bottleBodyMat,
          waterGeo,
          waterMat,
          capGeo,
          capMat,
          labelGeo,
          labelMat,
          dropGeo,
          dropMat;

        switch (tier) {
          case 0: // Initial Plastic Bottle
            bottleBodyGeo = new THREE.CylinderGeometry(1.5, 1.5, 5, 32);
            bottleBodyMat = new THREE.MeshPhysicalMaterial({
              color: 0xaec6cf,
              metalness: 0.1,
              roughness: 0.1,
              transmission: 0.6,
              transparent: true,
              opacity: 0.7,
            });
            waterGeo = new THREE.CylinderGeometry(1.4, 1.4, 4, 32);
            waterMat = new THREE.MeshPhongMaterial({
              color: 0x3498db,
              transparent: true,
              opacity: 0.9,
              shininess: 100,
            });
            capGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.5, 32);
            capMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            labelGeo = new THREE.CylinderGeometry(
              1.52,
              1.52,
              1.5,
              32,
              1,
              true,
              0,
              Math.PI
            );
            labelMat = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
            });
            dropGeo = new THREE.ConeGeometry(0.3, 0.6, 32);
            dropMat = new THREE.MeshBasicMaterial({ color: 0x3498db });
            break;
          case 1: // Refined Glass Bottle
            bottleBodyGeo = new THREE.CylinderGeometry(1.4, 1.6, 5.5, 64);
            bottleBodyMat = new THREE.MeshPhysicalMaterial({
              color: 0xcfe2f3,
              metalness: 0.2,
              roughness: 0,
              transmission: 0.9,
              transparent: true,
              opacity: 0.8,
            });
            waterGeo = new THREE.CylinderGeometry(1.3, 1.5, 4.5, 64);
            waterMat = new THREE.MeshPhongMaterial({
              color: 0x5dade2,
              transparent: true,
              opacity: 0.95,
              shininess: 150,
              emissive: 0x1a70b0,
              emissiveIntensity: 0.1,
            });
            capGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.6, 32);
            capMat = new THREE.MeshStandardMaterial({
              color: 0x6a7d8e,
              metalness: 0.5,
            });
            break;
          case 2: // Crystal Vessel
            bottleBodyGeo = new THREE.OctahedronGeometry(2.5, 1);
            bottleBodyMat = new THREE.MeshPhysicalMaterial({
              color: 0xb0e0e6,
              metalness: 0.3,
              roughness: 0,
              transmission: 0.95,
              transparent: true,
              opacity: 0.9,
              clearcoat: 1,
              clearcoatRoughness: 0.1,
            });
            waterGeo = new THREE.OctahedronGeometry(2, 1);
            waterMat = new THREE.MeshPhongMaterial({
              color: 0x87cefa,
              transparent: true,
              opacity: 0.98,
              shininess: 200,
              emissive: 0x4682b4,
              emissiveIntensity: 0.3,
            });
            capGeo = new THREE.ConeGeometry(1.8, 1, 32);
            capMat = new THREE.MeshStandardMaterial({
              color: 0x778899,
              metalness: 0.8,
              roughness: 0.2,
            });
            break;
          case 3: // Futuristic Collector
            bottleBodyGeo = new THREE.TorusKnotGeometry(1.5, 0.5, 100, 16);
            bottleBodyMat = new THREE.MeshPhysicalMaterial({
              color: 0xa2cffe,
              metalness: 0.8,
              roughness: 0.1,
              clearcoat: 1,
              clearcoatRoughness: 0,
              transmission: 0.9,
              transparent: true,
              opacity: 0.95,
            });
            waterGeo = new THREE.TorusKnotGeometry(1.4, 0.4, 100, 16);
            waterMat = new THREE.MeshPhongMaterial({
              color: 0x89cff0,
              transparent: true,
              opacity: 0.99,
              shininess: 250,
              emissive: 0x00bfff,
              emissiveIntensity: 0.6,
            });
            capGeo = new THREE.SphereGeometry(1.2, 32, 32);
            capMat = new THREE.MeshStandardMaterial({
              color: 0x5f9ea0,
              metalness: 0.9,
              roughness: 0.1,
            });
            break;
          case 4: // Monumental Source
            bottleBodyGeo = new THREE.DodecahedronGeometry(2.8);
            bottleBodyMat = new THREE.MeshPhysicalMaterial({
              color: 0xe0ffff,
              metalness: 1,
              roughness: 0,
              clearcoat: 1,
              clearcoatRoughness: 0,
              transmission: 1,
              transparent: true,
              opacity: 1,
            });
            waterGeo = new THREE.DodecahedronGeometry(2.5);
            waterMat = new THREE.MeshPhongMaterial({
              color: 0xb0e0e6,
              transparent: true,
              opacity: 1,
              shininess: 300,
              emissive: 0x00ffff,
              emissiveIntensity: 1.0,
            });
            capGeo = new THREE.TetrahedronGeometry(1.5);
            capMat = new THREE.MeshStandardMaterial({
              color: 0x6495ed,
              metalness: 1,
              roughness: 0,
            });
            break;
        }

        bottleMesh = new THREE.Mesh(bottleBodyGeo, bottleBodyMat);
        bottleMesh.position.y = 0;
        bottleGroup.add(bottleMesh);

        waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.position.y = tier === 3 || tier === 4 ? 0 : -0.4;
        bottleGroup.add(waterMesh);

        if (capGeo) {
          capMesh = new THREE.Mesh(capGeo, capMat);
          capMesh.position.y =
            tier === 0
              ? 2.75
              : tier === 1
              ? 3
              : tier === 2
              ? 3.5
              : tier === 3
              ? 2.5
              : 3.8;
          bottleGroup.add(capMesh);
        }

        if (tier === 0) {
          labelMesh = new THREE.Mesh(labelGeo, labelMat);
          labelMesh.rotation.y = -Math.PI / 2;
          bottleGroup.add(labelMesh);

          dropMesh = new THREE.Mesh(dropGeo, dropMat);
          dropMesh.position.z = 1.55;
          dropMesh.rotation.x = Math.PI / 6;
          bottleGroup.add(dropMesh);
        }
      }

      function createParticles() {
        const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMat = new THREE.MeshBasicMaterial({
          color: 0x00d2d3,
          transparent: true,
          opacity: 0.8,
        });

        for (let i = 0; i < 30; i++) {
          const mesh = new THREE.Mesh(particleGeo, particleMat);
          mesh.visible = false;
          scene.add(mesh);
          bubbles.push({ mesh: mesh, life: 0, velocity: new THREE.Vector3() });
        }
      }

      function handleBottleClick(screenX, screenY) {
        addWater(game.clickPower);
        spawnFloatingText(screenX, screenY, game.clickPower);

        bottleGroup.scale.set(1.1, 0.9, 1.1);
        setTimeout(() => {
          bottleGroup.scale.set(1, 1, 1);
        }, 100);

        triggerParticles(Math.min(20, Math.floor(game.clickPower / 5) + 5));
      }

      function triggerParticles(count = 10) {
        let triggered = 0;
        for (let i = 0; i < bubbles.length && triggered < count; i++) {
          const b = bubbles[i];
          if (!b.mesh.visible) {
            b.mesh.visible = true;
            b.life = 1.0;
            b.mesh.position.set(
              (Math.random() - 0.5) * 2,
              0,
              (Math.random() - 0.5) * 2 + 1
            );
            b.velocity.set(
              (Math.random() - 0.5) * 0.2,
              Math.random() * 0.2 + 0.1,
              (Math.random() - 0.5) * 0.2
            );
            triggered++;
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- Main Loop ---

      let lastTime = 0;

      function animate(time) {
        requestAnimationFrame(animate);

        const delta = (time - lastTime) / 1000;
        lastTime = time;

        // Idle Rotation
        if (bottleGroup) {
          bottleGroup.rotation.y += 0.005;
          bottleGroup.position.y = Math.sin(time / 1000) * 0.2; // Bobbing
        }

        // Particle Logic
        bubbles.forEach((b) => {
          if (b.mesh.visible) {
            b.mesh.position.add(b.velocity);
            b.velocity.y -= 0.01; // Gravity
            b.life -= 0.02;
            b.mesh.scale.setScalar(b.life);

            if (b.life <= 0) b.mesh.visible = false;
          }
        });

        // Game Loop Logic
        if (delta && delta < 1) {
          const mps = calculateMPS();
          if (mps > 0) {
            addWater(mps * delta);
          }
        }

        updateUI();

        composer.render(); // Use composer instead of renderer for bloom
      }

      // --- Initialization ---

      window.onload = () => {
        loadGame();
        initThree();

        autoSaveInterval = setInterval(() => {
          saveGame(true);
        }, 10000);
      };

      window.onbeforeunload = () => {
        saveGame();
      };
    </script>
  </body>
</html>
