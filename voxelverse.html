<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxel World (Three.js)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #87ceeb;
        font-family: "Segoe UI", sans-serif;
      }

      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10,0 L10,20 M0,10 L20,10" stroke="white" stroke-width="2" fill="none"/></svg>');
        transform: translate(-50%, -50%);
        pointer-events: none;
        mix-blend-mode: difference;
      }

      #ui {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 8px;
        pointer-events: none;
      }

      .slot {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 0 #000;
      }

      .slot.active {
        border-color: #fff;
        transform: scale(1.1);
        background: rgba(255, 255, 255, 0.2);
      }

      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        text-align: center;
      }

      h1 {
        margin: 0;
        font-size: 3rem;
        text-shadow: 4px 4px 0 #444;
      }
      p {
        font-size: 1.2rem;
        color: #ccc;
      }
      .key {
        display: inline-block;
        padding: 2px 6px;
        background: #444;
        border-radius: 4px;
        border-bottom: 2px solid #222;
        font-family: monospace;
      }

      #debug {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="crosshair"></div>
    <div id="debug">FPS: 0 | Chunks: 1</div>

    <div id="ui">
      <div class="slot active" id="slot-1" style="background-color: #5d9e52">
        1
      </div>
      <div class="slot" id="slot-2" style="background-color: #70543e">2</div>
      <div class="slot" id="slot-3" style="background-color: #777">3</div>
      <div class="slot" id="slot-4" style="background-color: #8b5a2b">4</div>
      <div class="slot" id="slot-5" style="background-color: #a4c96a">5</div>
    </div>

    <div id="overlay">
      <h1>VOXEL VERSE</h1>
      <p>Click to Start</p>
      <br />
      <p>
        <span class="key">WASD</span> Move &nbsp;
        <span class="key">SPACE</span> Jump
      </p>
      <p>
        <span class="key">L-CLICK</span> Break &nbsp;
        <span class="key">R-CLICK</span> Place
      </p>
      <p><span class="key">1-5</span> Select Block</p>
    </div>

    <!-- Import Three.js -->
    <script type="module">
      import * as THREE from "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js";

      // --- CONFIGURATION ---
      const WORLD_SIZE = 48; // Size of the generated platform
      const WORLD_HEIGHT = 16;
      const MAX_INSTANCES = 10000; // Max blocks per type

      // Block Types
      const BLOCKS = {
        GRASS: 1,
        DIRT: 2,
        STONE: 3,
        WOOD: 4,
        LEAVES: 5,
        BEDROCK: 99,
      };

      const BLOCK_PROPS = {
        1: { color: "#5d9e52", name: "Grass" },
        2: { color: "#70543e", name: "Dirt" },
        3: { color: "#777777", name: "Stone" },
        4: { color: "#8b5a2b", name: "Wood" },
        5: { color: "#a4c96a", name: "Leaves" },
        99: { color: "#222222", name: "Bedrock" },
      };

      // --- STATE ---
      let camera, scene, renderer;
      let controlsLocked = false;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false,
        moveUp = false;
      let velocity = new THREE.Vector3();
      let direction = new THREE.Vector3();
      let prevTime = performance.now();
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();

      // World Data: A map of "x,y,z" string keys to Block IDs
      const worldData = new Map();

      // Instance Managers
      const instanceMeshes = {}; // type -> InstancedMesh
      const instanceCounts = {}; // type -> current count
      const instanceMatrices = {}; // type -> Array of matrices (helper)

      let selectedBlock = BLOCKS.GRASS;
      const playerSize = { h: 1.8, w: 0.3 };

      // --- TEXTURE GENERATION ---

      function createNoiseTexture(colorHex, noiseScale = 20) {
        const canvas = document.createElement("canvas");
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext("2d");

        // Base
        ctx.fillStyle = colorHex;
        ctx.fillRect(0, 0, 64, 64);

        // Noise
        for (let i = 0; i < 400; i++) {
          const x = Math.random() * 64;
          const y = Math.random() * 64;
          const w = Math.random() * 4 + 1;
          const h = Math.random() * 4 + 1;
          ctx.fillStyle =
            Math.random() > 0.5 ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.1)";
          ctx.fillRect(x, y, w, h);
        }

        // Border for voxel look
        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.lineWidth = 4;
        ctx.strokeRect(0, 0, 64, 64);

        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
      }

      // --- INITIALIZATION ---

      function init() {
        // 1. Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 20, 60);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(WORLD_SIZE / 2, 10, WORLD_SIZE / 2);

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: false }); // False for retro feel & performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 4. Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // 5. Initialize Instance Meshes
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);

        Object.keys(BLOCK_PROPS).forEach((type) => {
          const mat = new THREE.MeshStandardMaterial({
            map: createNoiseTexture(BLOCK_PROPS[type].color),
            roughness: 0.8,
          });
          const mesh = new THREE.InstancedMesh(boxGeo, mat, MAX_INSTANCES);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Optimizing for updates

          scene.add(mesh);
          instanceMeshes[type] = mesh;
          instanceCounts[type] = 0;

          // Hide all initially
          for (let i = 0; i < MAX_INSTANCES; i++) {
            mesh.setMatrixAt(
              i,
              new THREE.Matrix4().set(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              )
            ); // Zero scale
          }
        });

        // 6. Generate World
        generateWorld();

        // 7. Inputs
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        document.addEventListener("mousedown", onMouseDown);
        document.addEventListener("mousemove", onMouseMove); // Added listener
        window.addEventListener("resize", onWindowResize);
        document.addEventListener("click", () => {
          if (!controlsLocked) document.body.requestPointerLock();
        });
        document.addEventListener("pointerlockchange", () => {
          controlsLocked = document.pointerLockElement === document.body;
          document.getElementById("overlay").style.display = controlsLocked
            ? "none"
            : "flex";
        });
        document.addEventListener("wheel", onScroll);

        // Loop
        animate();
      }

      // --- WORLD GENERATION ---

      // Simple Pseudo Random
      function simpleNoise(x, z) {
        const s = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2;
        const n = Math.sin(x * 0.3 + z * 0.2) * 1.5;
        return Math.floor(s + n) + 5; // Base height 5
      }

      function setBlock(x, y, z, type) {
        const key = `${x},${y},${z}`;

        // If block exists, remove visual instance
        if (worldData.has(key)) {
          removeBlockVisual(x, y, z, worldData.get(key));
        }

        worldData.set(key, type);
        addBlockVisual(x, y, z, type);
      }

      function removeBlock(x, y, z) {
        const key = `${x},${y},${z}`;
        if (worldData.has(key)) {
          const type = worldData.get(key);
          if (type === BLOCKS.BEDROCK) return; // Unbreakable

          removeBlockVisual(x, y, z, type);
          worldData.delete(key);
        }
      }

      // This is a naive visual manager. In prod, use a sparse map.
      // To keep code small, we iterate instances to find the match.
      function removeBlockVisual(x, y, z, type) {
        const mesh = instanceMeshes[type];
        const dummy = new THREE.Object3D();

        // Linear search (Slow for huge counts, acceptable for demo < 5000)
        for (let i = 0; i < instanceCounts[type]; i++) {
          mesh.getMatrixAt(i, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          if (
            Math.abs(dummy.position.x - x) < 0.1 &&
            Math.abs(dummy.position.y - y) < 0.1 &&
            Math.abs(dummy.position.z - z) < 0.1
          ) {
            // Found it. Swap with last element to keep array packed.
            const lastIdx = instanceCounts[type] - 1;
            const matrix = new THREE.Matrix4();
            mesh.getMatrixAt(lastIdx, matrix);
            mesh.setMatrixAt(i, matrix); // Move last to current
            mesh.setMatrixAt(
              lastIdx,
              new THREE.Matrix4().set(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              )
            ); // Zero last

            instanceCounts[type]--;
            mesh.instanceMatrix.needsUpdate = true;
            return;
          }
        }
      }

      function addBlockVisual(x, y, z, type) {
        const mesh = instanceMeshes[type];
        const count = instanceCounts[type];

        if (count >= MAX_INSTANCES) return; // Full

        const dummy = new THREE.Object3D();
        dummy.position.set(x, y, z);
        dummy.updateMatrix();

        mesh.setMatrixAt(count, dummy.matrix);
        instanceCounts[type]++;
        mesh.instanceMatrix.needsUpdate = true;
      }

      function generateWorld() {
        // Ground
        for (let x = 0; x < WORLD_SIZE; x++) {
          for (let z = 0; z < WORLD_SIZE; z++) {
            // Bedrock
            setBlock(x, 0, z, BLOCKS.BEDROCK);

            const h = simpleNoise(x, z);

            for (let y = 1; y <= h; y++) {
              let type = BLOCKS.DIRT;
              if (y === h) type = BLOCKS.GRASS;
              if (y < 3) type = BLOCKS.STONE;

              setBlock(x, y, z, type);
            }

            // Trees (Randomly on top)
            if (x > 2 && x < WORLD_SIZE - 2 && z > 2 && z < WORLD_SIZE - 2) {
              if (Math.random() < 0.02) {
                generateTree(x, h + 1, z);
              }
            }
          }
        }
      }

      function generateTree(x, y, z) {
        // Trunk
        for (let i = 0; i < 4; i++) {
          setBlock(x, y + i, z, BLOCKS.WOOD);
        }
        // Leaves
        for (let lx = x - 2; lx <= x + 2; lx++) {
          for (let lz = z - 2; lz <= z + 2; lz++) {
            for (let ly = y + 2; ly <= y + 4; ly++) {
              if (
                Math.abs(lx - x) + Math.abs(lz - z) + Math.abs(ly - (y + 3)) <
                4
              ) {
                setBlock(lx, ly, lz, BLOCKS.LEAVES);
              }
            }
          }
        }
      }

      // --- PHYSICS & CONTROLS ---

      function getBlock(x, y, z) {
        return worldData.get(
          `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`
        );
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "Space":
            if (velocity.y === 0) velocity.y = 12; // Jump
            break;
          case "Digit1":
            selectBlock(1);
            break;
          case "Digit2":
            selectBlock(2);
            break;
          case "Digit3":
            selectBlock(3);
            break;
          case "Digit4":
            selectBlock(4);
            break;
          case "Digit5":
            selectBlock(5);
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
        }
      }

      function onMouseMove(event) {
        if (!controlsLocked) return;
        camera.rotation.y -= event.movementX * 0.002;
        camera.rotation.x -= event.movementY * 0.002;

        // Clamp vertical look to 90 degrees to prevent flipping
        const PI_2 = Math.PI / 2;
        camera.rotation.x = Math.max(-PI_2, Math.min(PI_2, camera.rotation.x));
      }

      function onScroll(event) {
        let next = selectedBlock + (event.deltaY > 0 ? 1 : -1);
        if (next > 5) next = 1;
        if (next < 1) next = 5;
        selectBlock(next);
      }

      function selectBlock(id) {
        selectedBlock = id;
        document
          .querySelectorAll(".slot")
          .forEach((el) => el.classList.remove("active"));
        document.getElementById(`slot-${id}`).classList.add("active");
      }

      function onMouseDown(event) {
        if (!controlsLocked) return;

        // Raycasting for block interaction
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

        // Get all instance meshes
        const meshes = Object.values(instanceMeshes);
        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          const hit = intersects[0];
          const p = hit.point;
          const n = hit.face.normal;

          // Calculate block coord
          // For breaking: go 0.5 units INTO the block to get its center index
          const breakPos = p.clone().sub(n.clone().multiplyScalar(0.5));
          const bx = Math.floor(breakPos.x);
          const by = Math.floor(breakPos.y);
          const bz = Math.floor(breakPos.z);

          if (event.button === 0) {
            // Left Click: Break
            removeBlock(bx, by, bz);
            createParticles(
              bx + 0.5,
              by + 0.5,
              bz + 0.5,
              BLOCK_PROPS[worldData.get(`${bx},${by},${bz}`)]?.color || "#555"
            );
          } else if (event.button === 2) {
            // Right Click: Place
            // Calculate adjacent block: Simply add the normal to the broken block index
            // (Since n is 1, 0 or -1, rounding it handles any float noise)
            const px = bx + Math.round(n.x);
            const py = by + Math.round(n.y);
            const pz = bz + Math.round(n.z);

            // Check collision with player
            const playerBox = new THREE.Box3();
            const center = new THREE.Vector3(
              camera.position.x,
              camera.position.y - playerSize.h / 2,
              camera.position.z
            );
            playerBox.setFromCenterAndSize(
              center,
              new THREE.Vector3(
                playerSize.w * 2,
                playerSize.h,
                playerSize.w * 2
              )
            );

            const blockBox = new THREE.Box3();
            blockBox.setFromCenterAndSize(
              new THREE.Vector3(px + 0.5, py + 0.5, pz + 0.5),
              new THREE.Vector3(1, 1, 1)
            );

            if (!playerBox.intersectsBox(blockBox)) {
              setBlock(px, py, pz, selectedBlock);
            }
          }
        }
      }

      // Helper particles
      let particles = [];
      function createParticles(x, y, z, color) {
        for (let i = 0; i < 8; i++) {
          const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
          const mat = new THREE.MeshBasicMaterial({ color: color });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(x, y, z);

          // Random velocity
          const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 5,
            Math.random() * 5,
            (Math.random() - 0.5) * 5
          );

          scene.add(mesh);
          particles.push({ mesh, vel, life: 1.0 });
        }
      }

      function updatePhysics(delta) {
        // 1. Friction / Drag
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        // 2. Gravity
        velocity.y -= 30.0 * delta; // 9.8 is too floaty for games

        // 3. Input Force
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        // Rotate move vector by camera Y rotation
        if (moveForward || moveBackward) {
          // We only care about Y rotation (yaw) for movement
          const yRotation = camera.rotation.y;
          const dz =
            direction.z * Math.cos(yRotation) -
            direction.x * Math.sin(yRotation);
          const dx =
            direction.z * Math.sin(yRotation) +
            direction.x * Math.cos(yRotation);
          velocity.z -= dz * 50.0 * delta;
          velocity.x -= dx * 50.0 * delta;
        } else if (moveLeft || moveRight) {
          // If only strafing (no forward/back), the above logic handles it if direction is set correctly,
          // but since we separate the if statements in the original, we should combine them or handle rotation properly.
          // Actually, let's just use the direction vector fully:
        }

        // Correct Movement Logic with Camera Rotation
        if (moveForward || moveBackward || moveLeft || moveRight) {
          const theta = camera.rotation.y;
          // Direction vector is relative to camera
          // Forward (Z) is cos(theta), Strafe (X) is sin(theta)
          // Standard WASD mapping relative to look direction:
          const v = new THREE.Vector3(direction.x, 0, direction.z);
          v.applyAxisAngle(new THREE.Vector3(0, 1, 0), theta);

          velocity.x -= v.x * 50.0 * delta;
          velocity.z -= v.z * 50.0 * delta;
        }

        // 4. Collision Detection (AABB)
        // We check X, Y, Z axes independently

        const steps = 5; // Sub-steps for high speed
        const dt = delta / steps;

        for (let s = 0; s < steps; s++) {
          // --- X Axis ---
          camera.position.x += velocity.x * dt;
          if (checkCollision(camera.position)) {
            camera.position.x -= velocity.x * dt;
            velocity.x = 0;
          }

          // --- Z Axis ---
          camera.position.z += velocity.z * dt;
          if (checkCollision(camera.position)) {
            camera.position.z -= velocity.z * dt;
            velocity.z = 0;
          }

          // --- Y Axis ---
          camera.position.y += velocity.y * dt;
          if (checkCollision(camera.position)) {
            camera.position.y -= velocity.y * dt;
            velocity.y = 0;
            // On ground?
            // If we were falling and hit something, we can jump again
          }
        }

        // Floor check simple
        if (camera.position.y < -20) {
          camera.position.set(WORLD_SIZE / 2, 20, WORLD_SIZE / 2);
          velocity.set(0, 0, 0);
        }
      }

      function checkCollision(pos) {
        // Player dimensions
        const w = playerSize.w; // radius
        const h = playerSize.h;

        // Check corners of bounding box
        // Min: x-w, y-h, z-w
        // Max: x+w, y, z+w (Camera is at eye level, roughly top)

        const xMin = Math.floor(pos.x - w);
        const xMax = Math.floor(pos.x + w);
        const yMin = Math.floor(pos.y - h); // Feet
        const yMax = Math.floor(pos.y); // Head
        const zMin = Math.floor(pos.z - w);
        const zMax = Math.floor(pos.z + w);

        for (let x = xMin; x <= xMax; x++) {
          for (let y = yMin; y <= yMax; y++) {
            for (let z = zMin; z <= zMax; z++) {
              if (worldData.has(`${x},${y},${z}`)) return true;
            }
          }
        }
        return false;
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;

        if (controlsLocked) {
          updatePhysics(delta);
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= delta * 2;
          p.vel.y -= 9.8 * delta;
          p.mesh.position.addScaledVector(p.vel, delta);
          p.mesh.rotation.x += delta;
          p.mesh.rotation.y += delta;

          if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
          }
        }

        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Start
      init();
    </script>
  </body>
</html>
