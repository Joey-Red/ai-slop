<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spy Hunter 3D Clone</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Courier New", Courier, monospace;
        user-select: none;
      }
      #game-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .hud-panel {
        background: rgba(0, 0, 0, 0.7);
        color: #0f0;
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        font-size: 20px;
        font-weight: bold;
        text-transform: uppercase;
        border-bottom: 2px solid #0f0;
      }
      .controls-hint {
        text-align: center;
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        padding-bottom: 10px;
        text-shadow: 1px 1px 0 #000;
      }
      #start-screen,
      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        z-index: 10;
        pointer-events: auto;
      }
      h1 {
        font-size: 60px;
        color: #ff3333;
        text-shadow: 4px 4px 0px #fff;
        margin-bottom: 10px;
        font-style: italic;
      }
      .btn {
        background: #ff3333;
        color: white;
        border: 2px solid white;
        padding: 15px 40px;
        font-size: 24px;
        cursor: pointer;
        font-family: inherit;
        text-transform: uppercase;
        margin-top: 20px;
        transition: transform 0.1s;
      }
      .btn:hover {
        background: #fff;
        color: #ff3333;
        transform: scale(1.05);
      }
      .hidden {
        display: none !important;
      }
      #score-val {
        color: #fff;
      }
    </style>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="game-container"></div>

    <div id="ui-layer">
      <div class="hud-panel">
        <div>Score: <span id="score-val">00000</span></div>
        <div>Health: <span id="health-val">100%</span></div>
      </div>
      <div class="controls-hint">ARROWS to Drive | 'Z' or SPACE to Shoot</div>
    </div>

    <div id="start-screen">
      <h1>AGENT RUN</h1>
      <p>Destroy enemy vehicles. Stay on the road.</p>
      <button class="btn" id="start-btn">Start Engine</button>
    </div>

    <div id="game-over-screen" class="hidden">
      <h1>MIA</h1>
      <p>Final Score: <span id="final-score">0</span></p>
      <button class="btn" id="restart-btn">Replay Mission</button>
    </div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // --- Game Constants & State ---
      const STATE = {
        isPlaying: false,
        score: 0,
        speed: 0,
        baseSpeed: 60, // World move speed
        maxSpeed: 120,
        minSpeed: 20,
        roadWidth: 26,
        laneWidth: 20,
      };

      const ASSETS = {}; // Store generated textures/materials

      // --- Three.js Setup ---
      const container = document.getElementById("game-container");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);
      // Fog for that retro "fade into distance" look
      // Fix: Increased far plane so enemies are visible when they spawn
      scene.fog = new THREE.Fog(0x222222, 60, 250);

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        300
      );
      camera.position.set(0, 35, 25);
      camera.lookAt(0, 0, -10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      scene.add(dirLight);

      // --- Asset Generation (Procedural Textures) ---
      function createTexture(width, height, drawFn) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        drawFn(ctx, width, height);
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.NearestFilter;
        tex.magFilter = THREE.NearestFilter;
        return tex;
      }

      function initAssets() {
        // 1. Road Texture
        ASSETS.roadTex = createTexture(512, 512, (ctx, w, h) => {
          // Grass
          ctx.fillStyle = "#2a6e2a";
          ctx.fillRect(0, 0, w, h);

          // Road surface
          const roadW = w * 0.6;
          const roadX = (w - roadW) / 2;
          ctx.fillStyle = "#333";
          ctx.fillRect(roadX, 0, roadW, h);

          // Side lines
          ctx.fillStyle = "#ccc";
          ctx.fillRect(roadX + 5, 0, 5, h);
          ctx.fillRect(roadX + roadW - 10, 0, 5, h);

          // Center dashes
          ctx.fillStyle = "#ebc934";
          const dashH = h / 4;
          for (let i = 0; i < 4; i++) {
            if (i % 2 === 0)
              ctx.fillRect(w / 2 - 2, i * dashH + 10, 4, dashH - 20);
          }
        });
        ASSETS.roadTex.wrapS = THREE.RepeatWrapping;
        ASSETS.roadTex.wrapT = THREE.RepeatWrapping;
        ASSETS.roadTex.repeat.set(1, 4); // Repeat vertically

        // 2. Car Materials
        ASSETS.matPlayer = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.2,
        });
        ASSETS.matEnemy = new THREE.MeshStandardMaterial({
          color: 0x334488,
          roughness: 0.3,
        });
        ASSETS.matEnemyCivilian = new THREE.MeshStandardMaterial({
          color: 0x882222,
          roughness: 0.3,
        });
        ASSETS.matTire = new THREE.MeshStandardMaterial({ color: 0x111111 });
        ASSETS.matWindshield = new THREE.MeshStandardMaterial({
          color: 0x112233,
          roughness: 0.1,
        });
        ASSETS.matBullet = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      }
      initAssets();

      // --- Game Objects ---

      // Ground
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshStandardMaterial({ map: ASSETS.roadTex });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      class Car {
        constructor(type) {
          this.type = type; // 'player', 'enemy'
          this.mesh = new THREE.Group();
          this.speed = 0;
          this.health = 100;
          this.isDead = false;
          this.width = 2.5;
          this.length = 4.5;

          this.buildMesh();
        }

        buildMesh() {
          const mainMat =
            this.type === "player" ? ASSETS.matPlayer : ASSETS.matEnemy;

          // Body
          const bodyGeo = new THREE.BoxGeometry(2.2, 1, 4.5);
          const body = new THREE.Mesh(bodyGeo, mainMat);
          body.position.y = 0.8;
          body.castShadow = true;
          this.mesh.add(body);

          // Cabin
          const cabinGeo = new THREE.BoxGeometry(1.8, 0.6, 2);
          const cabin = new THREE.Mesh(cabinGeo, ASSETS.matWindshield);
          cabin.position.set(0, 1.5, -0.5);
          this.mesh.add(cabin);

          // Wheels
          const wheelGeo = new THREE.BoxGeometry(0.4, 0.8, 0.8);
          const positions = [
            [-1.2, 0.4, 1.2],
            [1.2, 0.4, 1.2], // Front
            [-1.2, 0.4, -1.2],
            [1.2, 0.4, -1.2], // Rear
          ];
          positions.forEach((pos) => {
            const w = new THREE.Mesh(wheelGeo, ASSETS.matTire);
            w.position.set(...pos);
            this.mesh.add(w);
          });

          // Guns (Player only)
          if (this.type === "player") {
            const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 1);
            const gunL = new THREE.Mesh(
              gunGeo,
              new THREE.MeshStandardMaterial({ color: 0x333 })
            );
            const gunR = gunL.clone();
            gunL.position.set(-0.8, 1, -2);
            gunR.position.set(0.8, 1, -2);
            this.mesh.add(gunL);
            this.mesh.add(gunR);
          }

          scene.add(this.mesh);
        }

        setPosition(x, z) {
          this.mesh.position.set(x, 0, z);
        }

        update(delta) {
          // Lean effect on turn
          this.mesh.rotation.z = THREE.MathUtils.lerp(
            this.mesh.rotation.z,
            (this.velocityX || 0) * -0.05,
            0.1
          );
          // Bounce animation
          this.mesh.position.y = Math.sin(Date.now() * 0.02) * 0.05;
        }

        remove() {
          scene.remove(this.mesh);
          this.isDead = true;
        }
      }

      // --- Logic Managers ---

      const player = new Car("player");
      const enemies = [];
      const bullets = [];
      const particles = [];

      // Controls
      const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        z: false,
        " ": false,
      };
      window.addEventListener("keydown", (e) => (keys[e.key] = true));
      window.addEventListener("keyup", (e) => (keys[e.key] = false));

      // --- Game Loop Functions ---

      function spawnEnemy() {
        if (enemies.length > 4) return; // Max enemies
        // Fix: Increased spawn rate slightly (0.02 -> 0.03)
        if (Math.random() > 0.03) return;

        const enemy = new Car("enemy");

        // Fix: Spawn closer so they are visible immediately (reduced from -120)
        const spawnZ = -100;
        // Random lane (-8 to 8 approx)
        const spawnX = Math.random() * 16 - 8;

        enemy.setPosition(spawnX, spawnZ);
        enemy.speed = STATE.baseSpeed * (0.8 + Math.random() * 0.4); // Variable speed

        enemies.push(enemy);
      }

      function spawnExplosion(position, color) {
        for (let i = 0; i < 15; i++) {
          const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
          const mat = new THREE.MeshBasicMaterial({ color: color });
          const p = new THREE.Mesh(geo, mat);
          p.position.copy(position);

          // Random velocity
          p.userData.vel = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            (Math.random() + 0.5) * 15,
            (Math.random() - 0.5) * 20
          );

          scene.add(p);
          particles.push(p);
        }
      }

      function shoot() {
        const b1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 1),
          ASSETS.matBullet
        );
        const b2 = b1.clone();

        b1.position.set(
          player.mesh.position.x - 0.8,
          1,
          player.mesh.position.z - 2
        );
        b2.position.set(
          player.mesh.position.x + 0.8,
          1,
          player.mesh.position.z - 2
        );

        scene.add(b1);
        scene.add(b2);
        bullets.push(b1, b2);
      }

      let lastShot = 0;
      const SHOT_DELAY = 200;

      function updatePhysics(delta) {
        if (!STATE.isPlaying) return;

        // 1. Player Movement
        const acc = 40 * delta;
        const friction = 0.95;
        const turnSpeed = 25 * delta;

        // Speed
        if (keys.ArrowUp) STATE.speed += acc;
        else if (keys.ArrowDown) STATE.speed -= acc * 2;
        else STATE.speed *= 0.99; // Coasting friction

        // Clamp Speed
        STATE.speed = Math.max(
          STATE.minSpeed,
          Math.min(STATE.maxSpeed, STATE.speed)
        );

        // Steer
        let dx = 0;
        if (keys.ArrowLeft) dx = -turnSpeed;
        if (keys.ArrowRight) dx = turnSpeed;

        player.mesh.position.x += dx;
        player.velocityX = dx / delta; // For tilt effect

        // Road Bounds
        const limit = STATE.roadWidth / 2;
        // Off-road friction
        if (Math.abs(player.mesh.position.x) > 8) {
          STATE.speed *= 0.98;
          // Visual shake
          player.mesh.position.y += (Math.random() - 0.5) * 0.2;
        }
        // Hard limits
        if (player.mesh.position.x < -limit) player.mesh.position.x = -limit;
        if (player.mesh.position.x > limit) player.mesh.position.x = limit;

        // 2. World Movement (Texture Scroll)
        // Instead of moving the player forward in Z, we move the texture
        // and move enemies relative to the player.
        const distanceMoved = STATE.speed * delta;

        // Fix: Changed -= to += to make road appear to move TOWARDS the camera (forward driving)
        ASSETS.roadTex.offset.y += distanceMoved * 0.02;

        // 3. Update Enemies (Relative Z movement)
        enemies.forEach((e) => {
          // Relative speed difference
          // If enemy is slower than player, it moves towards camera (+Z)
          // If enemy is faster, it moves away (-Z)
          const relSpeed = e.speed - STATE.speed;
          e.mesh.position.z -= relSpeed * delta;

          // Basic AI: Steer towards player slowly
          if (e.mesh.position.z > -60 && e.mesh.position.z < 20) {
            const dir = Math.sign(player.mesh.position.x - e.mesh.position.x);
            e.mesh.position.x += dir * 10 * delta;
          }

          e.update(delta);

          // Collision: Player vs Enemy
          const boxP = new THREE.Box3().setFromObject(player.mesh);
          const boxE = new THREE.Box3().setFromObject(e.mesh);

          // Shrink boxes slightly for forgiveness
          boxP.expandByScalar(-0.2);
          boxE.expandByScalar(-0.2);

          if (boxP.intersectsBox(boxE)) {
            // Damage
            player.health -= 20 * delta;
            // Push apart
            const pushDir = player.mesh.position.x < e.mesh.position.x ? -1 : 1;
            player.mesh.position.x += pushDir * 0.5;
            e.mesh.position.x -= pushDir * 0.5;
            spawnExplosion(
              player.mesh.position
                .clone()
                .add(e.mesh.position)
                .multiplyScalar(0.5),
              0xaaaaaa
            ); // Sparks
          }
        });

        // Remove off-screen enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const z = enemies[i].mesh.position.z;
          // Behind camera or too far ahead
          if (z > 20 || z < -200) {
            enemies[i].remove();
            enemies.splice(i, 1);
          } else if (enemies[i].isDead) {
            enemies.splice(i, 1);
          }
        }

        spawnEnemy();

        // 4. Bullets
        if ((keys.z || keys[" "]) && Date.now() - lastShot > SHOT_DELAY) {
          shoot();
          lastShot = Date.now();
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          // Bullets move physically forward relative to world, but we simulate relative to player
          // Bullet speed is very high
          b.position.z -= (150 + STATE.speed) * delta;

          // Check collision with enemies
          let hit = false;
          const bBox = new THREE.Box3().setFromObject(b);

          for (let e of enemies) {
            const eBox = new THREE.Box3().setFromObject(e.mesh);
            if (bBox.intersectsBox(eBox)) {
              hit = true;
              e.health -= 35;
              if (e.health <= 0) {
                spawnExplosion(e.mesh.position, 0xff5500);
                e.remove();
                STATE.score += 100;
              } else {
                // Hit effect
                spawnExplosion(b.position, 0xffff00);
              }
              break;
            }
          }

          if (hit || b.position.z < -150) {
            scene.remove(b);
            bullets.splice(i, 1);
          }
        }

        // 5. Particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.position.add(p.userData.vel.clone().multiplyScalar(delta));
          p.userData.vel.y -= 30 * delta; // Gravity
          p.scale.multiplyScalar(0.9); // Shrink
          p.rotation.x += delta * 5;

          if (p.position.y < 0 || p.scale.x < 0.05) {
            scene.remove(p);
            particles.splice(i, 1);
          }
        }

        // 6. Game Loop updates
        player.update(delta);
        player.mesh.rotation.x = 0; // Reset tilt from collisions

        // Score accumulation for distance
        STATE.score += STATE.speed * delta * 0.1;

        // Check Death
        if (player.health <= 0) {
          gameOver();
        }

        // UI Update
        updateUI();
      }

      function updateUI() {
        document.getElementById("score-val").innerText = Math.floor(STATE.score)
          .toString()
          .padStart(5, "0");
        const hEl = document.getElementById("health-val");
        hEl.innerText = Math.floor(player.health) + "%";
        hEl.style.color = player.health < 30 ? "red" : "#0f0";
      }

      function resetGame() {
        player.health = 100;
        player.setPosition(0, 0);
        STATE.score = 0;
        STATE.speed = STATE.baseSpeed;

        // Clear enemies/bullets
        enemies.forEach((e) => e.remove());
        enemies.length = 0;
        bullets.forEach((b) => scene.remove(b));
        bullets.length = 0;

        STATE.isPlaying = true;
        document.getElementById("start-screen").classList.add("hidden");
        document.getElementById("game-over-screen").classList.add("hidden");
      }

      function gameOver() {
        STATE.isPlaying = false;
        document.getElementById("final-score").innerText = Math.floor(
          STATE.score
        );
        document.getElementById("game-over-screen").classList.remove("hidden");
      }

      // --- Main Animation Loop ---
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent glitches

        updatePhysics(delta);

        // Camera follows player loosely (Smooth follow)
        camera.position.x = THREE.MathUtils.lerp(
          camera.position.x,
          player.mesh.position.x * 0.5,
          delta * 2
        );

        renderer.render(scene, camera);
      }

      // --- Events ---
      document.getElementById("start-btn").addEventListener("click", resetGame);
      document
        .getElementById("restart-btn")
        .addEventListener("click", resetGame);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start Loop
      animate();
    </script>
  </body>
</html>
