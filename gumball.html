<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cozy Gumball POV</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #ffe4e1;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
      }
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 1s;
      }
      #insert-coin-btn {
        pointer-events: auto;
        padding: 15px 40px;
        font-size: 24px;
        background: #ff6b6b;
        color: white;
        border: 4px solid white;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0 10px 25px rgba(255, 107, 107, 0.4);
        font-weight: bold;
        letter-spacing: 1px;
        transition: transform 0.2s, background 0.2s;
        text-transform: uppercase;
      }
      #insert-coin-btn:hover {
        transform: scale(1.05);
        background: #ff8787;
      }
      #insert-coin-btn:active {
        transform: scale(0.95);
      }
      .hidden {
        opacity: 0;
        pointer-events: none !important;
      }

      #instructions {
        position: absolute;
        bottom: 20px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 14px;
        text-align: center;
        width: 100%;
      }
    </style>
    <!-- Import Three.js and OrbitControls from CDN -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="canvas-container"></div>

    <div id="ui-layer">
      <div style="text-align: center">
        <h1
          style="
            color: #d65a5a;
            text-shadow: 2px 2px 0px white;
            font-size: 3rem;
            margin-bottom: 10px;
          "
        >
          Gumball POV
        </h1>
        <p style="color: #888; margin-bottom: 30px">Experience the tumble.</p>
        <button id="insert-coin-btn">INSERT QUARTER (25Â¢)</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { RectAreaLightUniformsLib } from "three/addons/lights/RectAreaLightUniformsLib.js";

      // --- SCENE SETUP ---
      const container = document.getElementById("canvas-container");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffe4e1); // Misty Rose background
      scene.fog = new THREE.Fog(0xffe4e1, 20, 100);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      RectAreaLightUniformsLib.init();

      // --- GAME STATE ---
      const STATE = {
        IDLE: 0,
        TRANSITION: 1,
        ROLLING: 2,
        FINISHED: 3,
      };
      let currentState = STATE.IDLE;
      let progress = 0; // Progress along the track (0 to 1)
      let speed = 0;

      // --- LIGHTING (Cozy & Warm) ---
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const sunLight = new THREE.DirectionalLight(0xfff0dd, 1.5);
      sunLight.position.set(10, 20, 10);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);

      const softFill = new THREE.PointLight(0xffccaa, 0.5);
      softFill.position.set(-5, 5, -5);
      scene.add(softFill);

      // --- TEXTURE GENERATORS ---
      // Create a noise texture for the gumball
      function createNoiseTexture() {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, size, size);

        for (let i = 0; i < 5000; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = Math.random() * 2;
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        const tex = new THREE.CanvasTexture(canvas);
        return tex;
      }

      // Create a simple wallpaper texture
      function createWallpaperTexture() {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        // Background
        ctx.fillStyle = "#FDF5E6"; // Old Lace
        ctx.fillRect(0, 0, size, size);

        // Stripes
        ctx.fillStyle = "#F0E68C"; // Khaki
        for (let i = 0; i < size; i += 40) {
          ctx.fillRect(i, 0, 20, size);
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4, 4);
        return tex;
      }

      // --- OBJECT CREATION ---

      // 1. The Room (Outside World)
      const roomGeo = new THREE.BoxGeometry(50, 50, 50);
      const roomMat = new THREE.MeshStandardMaterial({
        map: createWallpaperTexture(),
        side: THREE.BackSide,
      });
      const room = new THREE.Mesh(roomGeo, roomMat);
      room.position.y = 20;
      scene.add(room);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(100, 100);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // 2. The Giant Child (Looking In)
      const childGroup = new THREE.Group();

      // Skin Material
      const skinMat = new THREE.MeshStandardMaterial({
        color: 0xffcd94,
        roughness: 0.4,
      });
      const hairMat = new THREE.MeshStandardMaterial({
        color: 0x5d4037,
        roughness: 0.9,
      });
      const shirtMat = new THREE.MeshStandardMaterial({
        color: 0x6495ed,
        roughness: 0.6,
      });

      // Head
      const headGeo = new THREE.SphereGeometry(6, 32, 32);
      const head = new THREE.Mesh(headGeo, skinMat);
      head.position.set(0, 16, 12); // Outside the machine, looking in
      head.castShadow = true;
      childGroup.add(head);

      // Hair
      const hairGeo = new THREE.SphereGeometry(
        6.2,
        32,
        32,
        0,
        Math.PI * 2,
        0,
        Math.PI / 2.5
      );
      const hair = new THREE.Mesh(hairGeo, hairMat);
      hair.position.copy(head.position);
      hair.rotation.x = -Math.PI / 6;
      childGroup.add(hair);

      // Eyes (Simple cute dots)
      const eyeGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-1.5, 16, 7); // Closer to machine
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(1.5, 16, 7);
      childGroup.add(leftEye);
      childGroup.add(rightEye);

      // Body
      const bodyGeo = new THREE.CylinderGeometry(4, 8, 10, 32);
      const body = new THREE.Mesh(bodyGeo, shirtMat);
      body.position.set(0, 7, 14);
      body.rotation.x = -Math.PI / 8;
      childGroup.add(body);

      // Hands (resting on table/base maybe?)
      const handGeo = new THREE.SphereGeometry(1.5, 16, 16);
      const leftHand = new THREE.Mesh(handGeo, skinMat);
      leftHand.position.set(-5, 5, 5);
      const rightHand = new THREE.Mesh(handGeo, skinMat);
      rightHand.position.set(5, 5, 5);
      childGroup.add(leftHand);
      childGroup.add(rightHand);

      scene.add(childGroup);

      // 3. The Gumball Machine
      const machineGroup = new THREE.Group();
      scene.add(machineGroup);

      // Base
      const baseMat = new THREE.MeshPhysicalMaterial({
        color: 0xd32f2f, // Vintage Red
        metalness: 0.3,
        roughness: 0.4,
        clearcoat: 0.5,
      });

      const baseGeo = new THREE.CylinderGeometry(5, 6, 2, 64);
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 1;
      base.castShadow = true;
      base.receiveShadow = true;
      machineGroup.add(base);

      const stemGeo = new THREE.CylinderGeometry(2, 2, 8, 32);
      const stem = new THREE.Mesh(stemGeo, baseMat);
      stem.position.y = 5;
      machineGroup.add(stem);

      const bowlBaseGeo = new THREE.CylinderGeometry(5.5, 2, 2, 64);
      const bowlBase = new THREE.Mesh(bowlBaseGeo, baseMat);
      bowlBase.position.y = 9;
      bowlBase.castShadow = true;
      machineGroup.add(bowlBase);

      // The Glass Globe
      const glassGeo = new THREE.SphereGeometry(7, 64, 64);
      const glassMat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0,
        transmission: 0.95, // Glass-like transparency
        thickness: 0.5,
        clearcoat: 1,
        side: THREE.DoubleSide, // Important to see from inside
        ior: 1.5,
      });
      const globe = new THREE.Mesh(glassGeo, glassMat);
      globe.position.y = 15;
      machineGroup.add(globe);

      // Metal Cap
      const capGeo = new THREE.CylinderGeometry(0.5, 3, 1.5, 32);
      const cap = new THREE.Mesh(
        capGeo,
        new THREE.MeshStandardMaterial({
          color: 0xaaaaaa,
          metalness: 0.8,
          roughness: 0.2,
        })
      );
      cap.position.y = 22;
      machineGroup.add(cap);

      // Coin Slot Mechanism (Visual only)
      const slotGeo = new THREE.BoxGeometry(3, 3, 1);
      const chromeMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.9,
        roughness: 0.1,
      });
      const slot = new THREE.Mesh(slotGeo, chromeMat);
      slot.position.set(0, 9, 4.5); // Front of bowl base
      slot.rotation.x = -Math.PI / 10;
      machineGroup.add(slot);

      // 4. The Spiral Track
      // We generate a spiral path using CatmullRomCurve3
      const spiralPoints = [];
      const turns = 4;
      const heightStart = 19;
      const heightEnd = 10;
      const radiusStart = 6;
      const radiusEnd = 2.5; // Tapers in

      for (let i = 0; i <= 100; i++) {
        const t = i / 100;
        const angle = t * turns * Math.PI * 2;
        const r = radiusStart * (1 - t) + radiusEnd * t;
        const h = heightStart * (1 - t) + heightEnd * t;

        // Add some wobble to make it look organic/toy-like
        spiralPoints.push(
          new THREE.Vector3(Math.cos(angle) * r, h, Math.sin(angle) * r)
        );
      }
      // Add exit chute points
      spiralPoints.push(new THREE.Vector3(0, 9, 3));
      spiralPoints.push(new THREE.Vector3(0, 5, 5)); // Out the chute

      const trackCurve = new THREE.CatmullRomCurve3(spiralPoints);

      // Render the track
      const tubeGeo = new THREE.TubeGeometry(trackCurve, 100, 0.8, 12, false);
      const tubeMat = new THREE.MeshPhysicalMaterial({
        color: 0xeeeeee,
        metalness: 0.1,
        roughness: 0.1,
        transmission: 0.6, // Semi-transparent plastic track
        thickness: 0.2,
        side: THREE.DoubleSide,
      });
      const trackMesh = new THREE.Mesh(tubeGeo, tubeMat);
      machineGroup.add(trackMesh);

      // 5. The Player (The Gumball)
      // We'll create it but hide it initially
      const ballGeo = new THREE.SphereGeometry(0.6, 32, 32);
      const ballMat = new THREE.MeshPhysicalMaterial({
        color: 0xff69b4, // Hot pink default
        roughness: 0.3,
        clearcoat: 0.3,
        map: createNoiseTexture(),
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      scene.add(ball);
      ball.visible = false; // Hide until game starts

      // Decorative Gumballs (Static ones at bottom of globe to make it look full)
      const decoBalls = new THREE.InstancedMesh(ballGeo, ballMat, 30);
      const dummy = new THREE.Object3D();
      const colors = [
        0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff,
      ];

      for (let i = 0; i < 30; i++) {
        dummy.position.set(
          (Math.random() - 0.5) * 8,
          11 + Math.random() * 2,
          (Math.random() - 0.5) * 8
        );
        // Keep them inside sphere approx
        if (dummy.position.distanceTo(new THREE.Vector3(0, 15, 0)) < 6.5) {
          dummy.scale.setScalar(1);
          dummy.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            0
          );
          dummy.updateMatrix();
          decoBalls.setMatrixAt(i, dummy.matrix);
          decoBalls.setColorAt(
            i,
            new THREE.Color(colors[Math.floor(Math.random() * colors.length)])
          );
        } else {
          decoBalls.setMatrixAt(i, new THREE.Matrix4().makeScale(0, 0, 0)); // Hide if outside
        }
      }
      decoBalls.instanceColor.needsUpdate = true;
      scene.add(decoBalls);

      // --- CONTROLS & ANIMATION LOGIC ---

      // Initial camera position (Viewing the machine)
      camera.position.set(0, 15, 30);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 12, 0);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // Helper Vectors
      const position = new THREE.Vector3();
      const tangent = new THREE.Vector3();
      const lookAtVec = new THREE.Vector3();
      const normal = new THREE.Vector3(0, 1, 0); // Up vector

      // UI Interaction
      document
        .getElementById("insert-coin-btn")
        .addEventListener("click", startGame);

      function startGame() {
        if (currentState !== STATE.IDLE) return;

        // Pick a random color for the player
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        ball.material.color.setHex(randomColor);

        // UI Transition
        document.getElementById("ui-layer").classList.add("hidden");
        controls.autoRotate = false;
        controls.enabled = false; // Disable orbit controls

        // Sequence
        currentState = STATE.TRANSITION;

        // 1. Zoom to slot
        const startPos = camera.position.clone();
        const endPos = new THREE.Vector3(0, 9, 10); // In front of slot
        const startTarget = controls.target.clone();
        const endTarget = new THREE.Vector3(0, 9, 0);

        let alpha = 0;

        function animateTransition() {
          if (currentState !== STATE.TRANSITION) return;

          alpha += 0.02;
          camera.position.lerpVectors(startPos, endPos, easeInOutCubic(alpha));
          controls.target.lerpVectors(
            startTarget,
            endTarget,
            easeInOutCubic(alpha)
          );
          camera.lookAt(controls.target);

          if (alpha < 1) {
            requestAnimationFrame(animateTransition);
          } else {
            // 2. Spawn Ball
            ball.visible = true;
            progress = 0;
            speed = 0;
            currentState = STATE.ROLLING;
          }
        }
        animateTransition();
      }

      // Easing function
      function easeInOutCubic(x) {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
      }

      // Main Animation Loop
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        if (currentState === STATE.IDLE) {
          controls.update();
        } else if (currentState === STATE.ROLLING) {
          // Physics Simulation Logic

          // Basic acceleration based on slope?
          // Or just constant acceleration for fun
          if (speed < 0.005) speed += 0.0001;

          progress += speed;

          if (progress >= 1) {
            progress = 1;
            currentState = STATE.FINISHED;
            // Reset after a delay
            setTimeout(() => {
              location.reload(); // Simple reset
            }, 3000);
          }

          // Get position on spiral
          trackCurve.getPointAt(progress, position);
          trackCurve.getTangentAt(progress, tangent).normalize();

          // Update Ball Position
          ball.position.copy(position);

          // Roll the ball (Visual only)
          // Axis of rotation is perpendicular to tangent and up
          const axis = new THREE.Vector3()
            .crossVectors(new THREE.Vector3(0, 1, 0), tangent)
            .normalize();
          ball.rotateOnWorldAxis(axis, speed * 20); // Spin based on speed

          // Update Camera (POV)
          // We want the camera to be slightly behind and above the ball
          // But also rotating with the spiral

          // Calculate "Up" relative to the spiral to avoid flipping
          // Simple method: Use the ball position relative to center Y axis
          const camOffset = tangent.clone().multiplyScalar(-1.5); // Behind
          camOffset.y += 0.8; // Above

          // Smooth camera movement
          const targetCamPos = position.clone().add(camOffset);
          camera.position.lerp(targetCamPos, 0.1);

          // Look slightly ahead of the ball
          const lookTarget = position
            .clone()
            .add(tangent.clone().multiplyScalar(2));
          camera.lookAt(lookTarget);
        }

        // Gently animate the giant child
        if (childGroup) {
          childGroup.rotation.y = Math.sin(clock.getElapsedTime() * 0.5) * 0.05; // Subtle head sway
          // Make child eyes track the ball if visible
          if (ball.visible) {
            // Simple lookAt logic for the whole head might be too much, let's just sway
          }
        }

        renderer.render(scene, camera);
      }

      // Handle Window Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
