<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cozy Bear: Toy Room Adventure</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700&display=swap");

      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Nunito", sans-serif;
        user-select: none;
      }

      #ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      /* Menu Screen */
      #main-menu {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
        padding: 40px;
        border-radius: 30px;
        text-align: center;
        pointer-events: auto;
        box-shadow: 0 10px 30px rgba(100, 100, 255, 0.2);
        border: 5px solid #fff;
      }

      h1 {
        font-family: "Fredoka One", cursive;
        color: #6b4c3a;
        font-size: 4rem;
        margin: 0 0 20px 0;
        text-shadow: 2px 2px 0px #ffcaaa;
      }

      p {
        color: #555;
        font-size: 1.2rem;
        margin-bottom: 30px;
      }

      button {
        background: linear-gradient(to bottom, #ff9a9e, #fad0c4);
        border: none;
        padding: 15px 40px;
        font-size: 1.5rem;
        color: white;
        font-family: "Fredoka One", cursive;
        border-radius: 50px;
        cursor: pointer;
        transition: transform 0.1s, box-shadow 0.1s;
        box-shadow: 0 5px 0 #e08085;
      }

      button:active {
        transform: translateY(4px);
        box-shadow: 0 1px 0 #e08085;
      }

      button:hover {
        filter: brightness(1.1);
      }

      /* HUD */
      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        display: none;
        color: #6b4c3a;
        font-weight: bold;
        text-shadow: 1px 1px 0 #fff;
        pointer-events: none;
      }

      .mode-indicator {
        font-family: "Fredoka One", cursive;
        font-size: 1.5rem;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px 20px;
        border-radius: 20px;
        margin-bottom: 10px;
      }

      .tool-indicator {
        font-size: 1.2rem;
        background: rgba(255, 255, 255, 0.6);
        padding: 5px 15px;
        border-radius: 15px;
        display: inline-block;
      }

      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        background: transparent;
        border: 3px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        display: none;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        transition: all 0.1s;
      }

      #crosshair.grapple-active {
        border-color: #ff6b6b; /* Red when firing */
        transform: translate(-50%, -50%) scale(0.8);
        border-width: 4px;
      }

      #crosshair.can-grapple {
        border-color: #4caf50; /* Green when target valid */
        background-color: rgba(76, 175, 80, 0.2);
        transform: translate(-50%, -50%) scale(1.2);
      }

      .controls-hint {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.3);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.9rem;
        display: none;
        white-space: nowrap;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <style>
      /* Minimal Floating Home Button */
      .home-nav-btn {
        position: fixed;
        top: 15px;
        left: 15px;
        z-index: 10000; /* Ensure it sits above game UI/Canvases */
        background: rgba(
          30,
          30,
          30,
          0.6
        ); /* Dark semi-transparent for contrast */
        color: #ffffff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(4px); /* Blurs background behind button */
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .home-nav-btn:hover {
        background: rgba(30, 30, 30, 0.9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      /* SVG Icon Style */
      .home-nav-icon {
        width: 16px;
        height: 16px;
      }
    </style>

    <!-- Link to your Hub (index.html) -->
    <a href="index.html" class="home-nav-btn">
      <svg
        class="home-nav-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
      <span>Back to Hub</span>
    </a>
    <div id="ui-container">
      <div id="main-menu">
        <h1>Beary Adventure</h1>
        <p>
          WASD: Move | SPACE: Jump<br />Click: Grapple | Q/Z: Fly Up/Down<br />Press
          'T' to Toggle Edit Mode
        </p>
        <button id="start-btn">Play Game</button>
      </div>

      <div id="hud">
        <div class="mode-indicator" id="mode-text">PLAY MODE</div>
        <div class="tool-indicator" id="tool-text" style="display: none">
          Tool: Block (1)
        </div>
      </div>

      <div id="crosshair"></div>
      <div class="controls-hint" id="controls-hint">
        WASD: Move | SPACE: Jump | CLICK: Grapple | T: Edit Mode
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";

      // --- CONFIGURATION ---
      const COLORS = {
        sky: 0x80c2e8, // Toy Story Blue
        ground: 0x6ea352, // Green Carpet
        bear: 0x8d5524,
        bearLight: 0xc68642,
        block: 0xffaa80,
        grappleLine: 0x333333,
        enemyWalker: 0xff99cc,
        enemyFlyer: 0xffdb4d,
      };

      // --- GLOBALS ---
      let scene, camera, renderer;
      let raycaster;
      let clock = new THREE.Clock();

      // Game State
      let isPlaying = false;
      let isEditorMode = false;
      let objects = []; // Collidable objects (platforms)
      let enemies = []; // Active enemies
      let particles = []; // Pop effects
      let canGrappleTarget = false; // Visual feedback state

      // Editor State
      let editorTool = "block"; // 'block', 'walker', 'flyer'
      let ghostMesh = null;

      // Player Physics
      const player = {
        mesh: null,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        onGround: false,
        speed: 10,
        jumpForce: 18, // Slightly higher jump for the big city
        gravity: 35,
        radius: 0.5,
        height: 1.5,
      };

      // Camera State
      const camState = {
        yaw: 0, // Horizontal rotation (radians)
        pitch: 0.3, // Vertical rotation (radians)
        distance: 8,
        sensitivity: 0.002,
      };

      // Grapple Hook
      const grapple = {
        active: false,
        target: new THREE.Vector3(),
        line: null,
        speed: 60,
        minDistance: 1,
      };

      // Editor
      const gridSize = 2;

      // --- INITIALIZATION ---
      function init() {
        // Scene Setup
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(COLORS.sky, 20, 120);

        // Apply Toy Story Wallpaper Texture
        scene.background = createToyStoryTexture();

        // Camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfff0dd, 0.9);
        dirLight.position.set(30, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // Raycaster
        raycaster = new THREE.Raycaster();

        // Initialization of World
        createPlayer();
        createLevel();
        updateGhostMesh(); // Init editor ghost

        // Listeners
        document.getElementById("start-btn").addEventListener("click", () => {
          document.body.requestPointerLock();
        });

        document.addEventListener("pointerlockchange", () => {
          if (document.pointerLockElement === document.body) {
            isPlaying = true;
            document.getElementById("main-menu").style.display = "none";
            document.getElementById("hud").style.display = "block";
            document.getElementById("crosshair").style.display = "block";
            document.getElementById("controls-hint").style.display = "block";
          } else {
            isPlaying = false;
            document.getElementById("main-menu").style.display = "flex";
            document.getElementById("hud").style.display = "none";
            document.getElementById("crosshair").style.display = "none";
            document.getElementById("controls-hint").style.display = "none";
          }
        });

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        document.addEventListener("mousedown", onMouseDown);
        window.addEventListener("resize", onWindowResize);

        animate();
      }

      // --- GENERATE TOY STORY TEXTURE ---
      function createToyStoryTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        // 1. Draw Sky Background
        ctx.fillStyle = "#80c2e8"; // Andy's Room Blue
        ctx.fillRect(0, 0, 512, 512);

        // 2. Cloud Drawing Function
        function drawCloud(x, y, scale) {
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          // A cloud is made of 3 circles
          ctx.arc(x, y, 30 * scale, 0, Math.PI * 2);
          ctx.arc(x + 25 * scale, y - 10 * scale, 35 * scale, 0, Math.PI * 2);
          ctx.arc(x + 50 * scale, y, 30 * scale, 0, Math.PI * 2);
          ctx.fill();
        }

        // 3. Draw Pattern
        // We draw clouds at offsets to make it tileable
        drawCloud(100, 100, 1);
        drawCloud(350, 250, 1);
        drawCloud(100, 400, 1);
        drawCloud(350, 500, 1); // Partial cloud for bottom wrapping
        drawCloud(350, -12, 1); // Partial cloud for top wrapping

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        // Repeat the texture 4 times around the sphere/background
        texture.repeat.set(4, 4);
        return texture;
      }

      // --- ASSET GENERATION ---

      function createPlayer() {
        const bearGroup = new THREE.Group();

        const material = new THREE.MeshStandardMaterial({
          color: COLORS.bear,
          roughness: 1,
        });
        const lightMaterial = new THREE.MeshStandardMaterial({
          color: COLORS.bearLight,
          roughness: 1,
        });
        const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

        // Body
        const bodyGeo = new THREE.SphereGeometry(0.6, 16, 16);
        bodyGeo.scale(1, 1.2, 0.8);
        const body = new THREE.Mesh(bodyGeo, material);
        body.position.y = 0.6;
        body.castShadow = true;
        bearGroup.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.45, 16, 16);
        const head = new THREE.Mesh(headGeo, material);
        head.position.y = 1.3;
        head.castShadow = true;
        bearGroup.add(head);

        // Ears
        const earGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const leftEar = new THREE.Mesh(earGeo, material);
        leftEar.position.set(-0.35, 1.6, 0);
        const rightEar = new THREE.Mesh(earGeo, material);
        rightEar.position.set(0.35, 1.6, 0);
        bearGroup.add(leftEar, rightEar);

        // Snout
        const snoutGeo = new THREE.SphereGeometry(0.15, 8, 8);
        snoutGeo.scale(1, 0.8, 0.6);
        const snout = new THREE.Mesh(snoutGeo, lightMaterial);
        snout.position.set(0, 1.3, 0.35);
        bearGroup.add(snout);

        const noseGeo = new THREE.SphereGeometry(0.05, 8, 8);
        const nose = new THREE.Mesh(noseGeo, blackMat);
        nose.position.set(0, 1.35, 0.48);
        bearGroup.add(nose);

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const leftEye = new THREE.Mesh(eyeGeo, blackMat);
        leftEye.position.set(-0.15, 1.4, 0.38);
        const rightEye = new THREE.Mesh(eyeGeo, blackMat);
        rightEye.position.set(0.15, 1.4, 0.38);
        bearGroup.add(leftEye, rightEye);

        // Limbs
        const limbGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const armL = new THREE.Mesh(limbGeo, material);
        armL.position.set(-0.6, 0.8, 0);
        const armR = new THREE.Mesh(limbGeo, material);
        armR.position.set(0.6, 0.8, 0);
        const legL = new THREE.Mesh(limbGeo, material);
        legL.position.set(-0.3, 0.2, 0);
        const legR = new THREE.Mesh(limbGeo, material);
        legR.position.set(0.3, 0.2, 0);
        bearGroup.add(armL, armR, legL, legR);

        scene.add(bearGroup);
        player.mesh = bearGroup;
      }

      function createBlock(x, y, z, w, h, d, color = COLORS.block) {
        const geo = new THREE.BoxGeometry(w, h, d);
        const mat = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.isBlock = true;

        scene.add(mesh);
        objects.push(mesh);
        return mesh;
      }

      function createEnemy(type, x, y, z) {
        const group = new THREE.Group();
        group.position.set(x, y, z);

        if (type === "walker") {
          // Stuffed Piggy
          const mat = new THREE.MeshStandardMaterial({
            color: COLORS.enemyWalker,
          });
          const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1), mat);
          body.castShadow = true;

          const nose = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.3, 0.2),
            new THREE.MeshStandardMaterial({ color: 0xffb3d9 })
          );
          nose.position.set(0, 0, 0.5);

          group.add(body);
          group.add(nose);

          // Logic data
          group.userData = {
            type: "walker",
            velocity: new THREE.Vector3(2, 0, 0),
            alive: true,
            radius: 0.6,
          };
        } else if (type === "flyer") {
          // Stuffed Bee
          const mat = new THREE.MeshStandardMaterial({
            color: COLORS.enemyFlyer,
          });
          const stripeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            mat
          );
          body.castShadow = true;

          const stripe = new THREE.Mesh(
            new THREE.TorusGeometry(0.4, 0.1, 8, 16),
            stripeMat
          );
          stripe.rotation.y = Math.PI / 2;

          const wingMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.7,
          });
          const wings = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 0.1, 0.4),
            wingMat
          );
          wings.position.y = 0.4;

          group.add(body);
          group.add(stripe);
          group.add(wings);

          // Logic data
          group.userData = {
            type: "flyer",
            startY: y,
            alive: true,
            radius: 0.6,
          };
        }

        scene.add(group);
        enemies.push(group);
        return group;
      }

      function createPopParticle(position) {
        const count = 10;
        for (let i = 0; i < count; i++) {
          const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
          const mat = new THREE.MeshBasicMaterial({
            color: Math.random() * 0xffffff,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.copy(position);

          // Random explosion velocity
          const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 5,
            Math.random() * 5 + 2,
            (Math.random() - 0.5) * 5
          );

          scene.add(mesh);
          particles.push({ mesh: mesh, velocity: vel, life: 1.0 });
        }
      }

      // --- MODIFIED LEVEL GENERATION ---
      function createLevel() {
        // Colors for toy blocks
        const toyColors = [0xff5555, 0x5555ff, 0xffff55, 0x55ff55, 0xffa500];

        // 1. The Big Carpet (Ground)
        createBlock(0, -1, 0, 80, 2, 80, COLORS.ground);

        // 2. Border Walls (Like skirtings or toy boxes)
        createBlock(-40, 2, 0, 2, 6, 80, 0xdddddd); // West
        createBlock(40, 2, 0, 2, 6, 80, 0xdddddd); // East
        createBlock(0, 2, -40, 80, 6, 2, 0xdddddd); // North
        createBlock(0, 2, 40, 80, 6, 2, 0xdddddd); // South

        // 3. Central "Toy City" Structures

        // Main Tower
        createBlock(0, 5, -10, 10, 10, 10, 0xcccccc); // Base
        createBlock(0, 12, -10, 6, 4, 6, 0xff5555); // Top red block
        createEnemy("walker", 0, 10.5, -10); // Guarding the tower

        // Bridge connecting to a floating platform
        createBlock(10, 8, -10, 10, 1, 4, 0x8b4513); // Wooden plank
        createBlock(20, 8, -10, 8, 1, 8, 0x5555ff); // Blue platform
        createEnemy("flyer", 20, 12, -10);

        // Staircase to the sky
        for (let i = 0; i < 8; i++) {
          const h = 2 + i * 2.5;
          const x = -15 - i * 3;
          createBlock(x, h, 5, 3, 1, 3, toyColors[i % toyColors.length]);
        }
        // High platform at top of stairs
        createBlock(-40, 20, 5, 10, 1, 10, 0xffff55);
        createEnemy("flyer", -35, 25, 5);

        // A "Castle" area
        createBlock(15, 2, 15, 4, 8, 4, 0x888888); // Pillar 1
        createBlock(25, 2, 15, 4, 8, 4, 0x888888); // Pillar 2
        createBlock(15, 2, 25, 4, 8, 4, 0x888888); // Pillar 3
        createBlock(25, 2, 25, 4, 8, 4, 0x888888); // Pillar 4
        // Roof
        createBlock(20, 6, 20, 16, 1, 16, 0x55ff55);
        createEnemy("walker", 20, 7, 20);

        // Random scattered blocks (parkour)
        for (let i = 0; i < 15; i++) {
          const x = (Math.random() - 0.5) * 60;
          const z = (Math.random() - 0.5) * 60;
          // Don't spawn too close to center
          if (Math.abs(x) > 10 || Math.abs(z) > 10) {
            const h = 2 + Math.random() * 6;
            createBlock(
              x,
              h / 2,
              z,
              2,
              h,
              2,
              toyColors[Math.floor(Math.random() * toyColors.length)]
            );
          }
        }
      }

      function updateGhostMesh() {
        if (ghostMesh) {
          scene.remove(ghostMesh);
          ghostMesh.geometry.dispose();
        }

        let geo, color;
        if (editorTool === "block") {
          geo = new THREE.BoxGeometry(gridSize, gridSize, gridSize);
          color = 0x00ff00;
        } else if (editorTool === "walker") {
          geo = new THREE.BoxGeometry(0.8, 0.6, 1);
          color = COLORS.enemyWalker;
        } else if (editorTool === "flyer") {
          geo = new THREE.SphereGeometry(0.5, 16, 16);
          color = COLORS.enemyFlyer;
        }

        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.5,
          wireframe: true,
        });

        ghostMesh = new THREE.Mesh(geo, mat);
        scene.add(ghostMesh);
        ghostMesh.visible = false;

        // Update UI text
        const toolNames = {
          block: "Block (1)",
          walker: "Enemy: Walker (2)",
          flyer: "Enemy: Flyer (3)",
        };
        const toolText = document.getElementById("tool-text");
        if (toolText) toolText.innerText = `Tool: ${toolNames[editorTool]}`;
      }

      // --- INPUT HANDLING ---
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        space: false,
        q: false,
        z: false,
      };

      function onKeyDown(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            keys.w = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            keys.a = true;
            break;
          case "ArrowDown":
          case "KeyS":
            keys.s = true;
            break;
          case "ArrowRight":
          case "KeyD":
            keys.d = true;
            break;
          case "KeyQ":
            keys.q = true;
            break;
          case "KeyZ":
            keys.z = true;
            break;
          case "Digit1":
            if (isEditorMode) {
              editorTool = "block";
              updateGhostMesh();
            }
            break;
          case "Digit2":
            if (isEditorMode) {
              editorTool = "walker";
              updateGhostMesh();
            }
            break;
          case "Digit3":
            if (isEditorMode) {
              editorTool = "flyer";
              updateGhostMesh();
            }
            break;
          case "Space":
            if (!isEditorMode && player.onGround)
              player.velocity.y = player.jumpForce;
            if (isEditorMode) keys.space = true;
            break;
          case "KeyT":
            if (isPlaying) {
              isEditorMode = !isEditorMode;
              toggleMode();
            }
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            keys.w = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            keys.a = false;
            break;
          case "ArrowDown":
          case "KeyS":
            keys.s = false;
            break;
          case "ArrowRight":
          case "KeyD":
            keys.d = false;
            break;
          case "KeyQ":
            keys.q = false;
            break;
          case "KeyZ":
            keys.z = false;
            break;
          case "Space":
            keys.space = false;
            break;
        }
      }

      function onMouseMove(event) {
        if (isPlaying) {
          camState.yaw -= event.movementX * camState.sensitivity;
          camState.pitch += event.movementY * camState.sensitivity;
          const limit = Math.PI / 2 - 0.1;
          camState.pitch = Math.max(-limit, Math.min(limit, camState.pitch));
        }
      }

      function onMouseDown(event) {
        if (!isPlaying) return;

        if (isEditorMode) {
          handleEditorClick(event.button);
        } else {
          if (event.button === 0) {
            shootGrapple();
          }
        }
      }

      // --- GAME LOGIC ---

      function toggleMode() {
        const hudText = document.getElementById("mode-text");
        const toolText = document.getElementById("tool-text");
        const hintText = document.getElementById("controls-hint");

        if (isEditorMode) {
          hudText.innerText = "EDITOR MODE";
          hudText.style.color = "blue";
          toolText.style.display = "inline-block";
          hintText.innerText =
            "WASD: Move | Q/Z: Fly | 1-3: Tools | CLICK: Place | T: Play";
          player.velocity.set(0, 0, 0);
          grapple.active = false;
          removeGrappleLine();
          player.mesh.visible = false;
        } else {
          hudText.innerText = "PLAY MODE";
          hudText.style.color = "#6b4c3a";
          toolText.style.display = "none";
          hintText.innerText =
            "WASD: Move | SPACE: Jump | CLICK: Grapple | T: Edit";
          ghostMesh.visible = false;
          player.mesh.visible = true;
        }
      }

      function checkGrappleTarget() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(objects);

        const crosshair = document.getElementById("crosshair");
        if (intersects.length > 0) {
          if (!canGrappleTarget) {
            canGrappleTarget = true;
            crosshair.classList.add("can-grapple");
          }
          return intersects[0].point;
        } else {
          if (canGrappleTarget) {
            canGrappleTarget = false;
            crosshair.classList.remove("can-grapple");
          }
          return null;
        }
      }

      function shootGrapple() {
        if (grapple.active) {
          grapple.active = false;
          removeGrappleLine();
          return;
        }

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
          grapple.target.copy(intersects[0].point);
          grapple.active = true;

          // Lift player slightly to allow ground grappling
          player.velocity.y = Math.max(player.velocity.y, 10);
          player.onGround = false;
          player.mesh.position.y += 0.2;

          const material = new THREE.LineBasicMaterial({
            color: COLORS.grappleLine,
            linewidth: 2,
          });
          const points = [player.mesh.position, grapple.target];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          grapple.line = new THREE.Line(geometry, material);
          scene.add(grapple.line);

          const crosshair = document.getElementById("crosshair");
          crosshair.classList.add("grapple-active");
          setTimeout(() => crosshair.classList.remove("grapple-active"), 200);
        }
      }

      function removeGrappleLine() {
        if (grapple.line) {
          scene.remove(grapple.line);
          grapple.line.geometry.dispose();
          grapple.line = null;
        }
      }

      function handleEditorClick(button) {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const hitObjects = [...objects, ...enemies]; // Can click on enemies to delete too
        const intersects = raycaster.intersectObjects(hitObjects, true); // Recursive for groups

        if (intersects.length > 0) {
          const intersect = intersects[0];
          let targetObj = intersect.object;
          // Traverse up to find the group/main mesh
          while (targetObj.parent && targetObj.parent !== scene) {
            targetObj = targetObj.parent;
          }

          // Calculate snap position
          const pos = new THREE.Vector3()
            .copy(intersect.point)
            .add(intersect.face.normal.multiplyScalar(gridSize / 2))
            .divideScalar(gridSize)
            .floor()
            .multiplyScalar(gridSize)
            .addScalar(gridSize / 2);

          if (button === 0) {
            // Left Click: Add
            if (editorTool === "block") {
              createBlock(pos.x, pos.y, pos.z, gridSize, gridSize, gridSize);
            } else if (editorTool === "walker") {
              createEnemy("walker", pos.x, pos.y, pos.z);
            } else if (editorTool === "flyer") {
              createEnemy("flyer", pos.x, pos.y, pos.z);
            }
          } else if (button === 2) {
            // Right Click: Remove
            // Check if it's an enemy
            const enemyIndex = enemies.indexOf(targetObj);
            if (enemyIndex > -1) {
              scene.remove(targetObj);
              enemies.splice(enemyIndex, 1);
            }
            // Check if it's a block (and not ground)
            else if (objects.includes(targetObj) && targetObj !== objects[0]) {
              scene.remove(targetObj);
              objects = objects.filter((obj) => obj !== targetObj);
            }
          }
        }
      }

      function updateEditorPreview() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0 && ghostMesh) {
          const intersect = intersects[0];
          ghostMesh.visible = true;

          const pos = new THREE.Vector3()
            .copy(intersect.point)
            .add(intersect.face.normal.multiplyScalar(gridSize / 2))
            .divideScalar(gridSize)
            .floor()
            .multiplyScalar(gridSize)
            .addScalar(gridSize / 2);

          ghostMesh.position.copy(pos);
        } else if (ghostMesh) {
          ghostMesh.visible = false;
        }
      }

      function updatePhysics(delta) {
        // Friction
        player.velocity.x -= player.velocity.x * 10.0 * delta;
        player.velocity.z -= player.velocity.z * 10.0 * delta;
        if (isEditorMode) player.velocity.y -= player.velocity.y * 5.0 * delta;

        // Editor Move
        if (isEditorMode) {
          if (keys.q) player.velocity.y += player.speed * 20 * delta;
          if (keys.z) player.velocity.y -= player.speed * 20 * delta;
        }

        // Input
        const inputVector = new THREE.Vector3(0, 0, 0);
        if (keys.w) inputVector.z -= 1;
        if (keys.s) inputVector.z += 1;
        if (keys.a) inputVector.x -= 1;
        if (keys.d) inputVector.x += 1;

        if (inputVector.lengthSq() > 0) {
          inputVector.normalize();
          const rotation = new THREE.Euler(0, camState.yaw, 0);
          inputVector.applyEuler(rotation);

          const speed = isEditorMode ? player.speed * 2 : player.speed;
          player.velocity.x += inputVector.x * speed * delta * 10;
          player.velocity.z += inputVector.z * speed * delta * 10;

          if (!isEditorMode) {
            const angle = Math.atan2(player.velocity.x, player.velocity.z);
            player.mesh.rotation.y = angle;
          }
        }

        // --- Grapple Logic ---
        if (grapple.active && !isEditorMode) {
          const playerPos = player.mesh.position;
          const dist = playerPos.distanceTo(grapple.target);
          const dir = new THREE.Vector3()
            .subVectors(grapple.target, playerPos)
            .normalize();

          if (dist > grapple.minDistance) {
            player.velocity.add(dir.multiplyScalar(grapple.speed * delta));
            // Small lift force to keep off ground while pulling
            player.velocity.y += 10 * delta;
          } else {
            grapple.active = false;
            removeGrappleLine();
          }

          if (grapple.line) {
            const positions = grapple.line.geometry.attributes.position.array;
            positions[0] = playerPos.x;
            positions[1] = playerPos.y + 0.5;
            positions[2] = playerPos.z;
            grapple.line.geometry.attributes.position.needsUpdate = true;
          }
        } else if (!isEditorMode) {
          player.velocity.y -= player.gravity * delta;
        }

        // --- Movement Application ---
        player.mesh.position.x += player.velocity.x * delta;
        player.mesh.position.y += player.velocity.y * delta;
        player.mesh.position.z += player.velocity.z * delta;

        // --- Enemy Logic & Collisions ---
        if (!isEditorMode) {
          for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            const data = enemy.userData;

            // Animation/AI
            if (data.type === "walker") {
              // Simple patrol
              enemy.position.x += data.velocity.x * delta;

              // Turn around if hitting air (simple boundary check) or random
              if (Math.random() < 0.01) data.velocity.x *= -1;

              // Bob
              enemy.children[0].position.y =
                Math.abs(Math.sin(Date.now() * 0.005)) * 0.2;
            } else if (data.type === "flyer") {
              // Hover sine wave
              enemy.position.y =
                data.startY + Math.sin(Date.now() * 0.003) * 1.5;
              // Rotate wings
              enemy.children[2].rotation.y += 0.2;
            }

            // Collision with Player
            const dist = player.mesh.position.distanceTo(enemy.position);
            if (dist < player.radius + data.radius) {
              // Check for Head Stomp (Player falling and above enemy)
              const isFalling = player.velocity.y < 0;
              const isAbove = player.mesh.position.y > enemy.position.y + 0.5;

              if (isFalling && isAbove) {
                // KILL ENEMY
                createPopParticle(enemy.position);
                scene.remove(enemy);
                enemies.splice(i, 1);

                // Bounce player
                player.velocity.y = 12;
              } else {
                // Player Hit (Bounce Back)
                const pushDir = new THREE.Vector3()
                  .subVectors(player.mesh.position, enemy.position)
                  .normalize();
                player.velocity.add(pushDir.multiplyScalar(20));
                player.velocity.y = 5;
              }
            }
          }
        }

        // --- Particle Logic ---
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.mesh.position.add(p.velocity.multiplyScalar(delta));
          p.velocity.y -= 10 * delta; // Gravity on confetti
          p.mesh.rotation.x += delta * 5;
          p.mesh.rotation.y += delta * 5;
          p.life -= delta;
          p.mesh.scale.multiplyScalar(0.9); // Shrink
          if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
          }
        }

        // --- Environment Collision ---
        player.onGround = false;

        if (!isEditorMode) {
          // Only check ground if we aren't actively being pulled fast (prevents jitter)
          // or if we are just starting grapple
          const downRay = new THREE.Raycaster(
            new THREE.Vector3(
              player.mesh.position.x,
              player.mesh.position.y + 0.5,
              player.mesh.position.z
            ),
            new THREE.Vector3(0, -1, 0),
            0,
            0.6
          );

          const hits = downRay.intersectObjects(objects);
          if (hits.length > 0) {
            // Don't snap to ground if grappling UPWARDS
            if (!grapple.active || player.velocity.y < 0) {
              player.velocity.y = Math.max(0, player.velocity.y);
              player.mesh.position.y = hits[0].point.y;
              player.onGround = true;

              // Stop grapple if we hit ground? Optional.
              // The user wants to grapple FROM ground, so we allow grapple to persist
              // But if we land, we usually want to stop being pulled eventually?
              // We'll leave grapple active until distance check fails or user clicks.
            }
          }

          if (player.mesh.position.y < -10) {
            player.mesh.position.set(0, 5, 0);
            player.velocity.set(0, 0, 0);
            grapple.active = false;
            removeGrappleLine();
          }
        }
      }

      function updateCamera() {
        if (isEditorMode) {
          const hDist = camState.distance * Math.cos(camState.pitch);
          const vDist = camState.distance * Math.sin(camState.pitch);
          const offsetX = hDist * Math.sin(camState.yaw);
          const offsetZ = hDist * Math.cos(camState.yaw);
          const offsetY = vDist;

          camera.position.set(
            player.mesh.position.x + offsetX,
            player.mesh.position.y + offsetY + 2,
            player.mesh.position.z + offsetZ
          );
          camera.lookAt(player.mesh.position);
        } else {
          const hDist = camState.distance * Math.cos(camState.pitch);
          const vDist = camState.distance * Math.sin(camState.pitch);
          const offsetX = hDist * Math.sin(camState.yaw);
          const offsetZ = hDist * Math.cos(camState.yaw);
          const offsetY = vDist;

          const pivotY = player.mesh.position.y + 2.5;
          const lookTarget = new THREE.Vector3(
            player.mesh.position.x,
            pivotY,
            player.mesh.position.z
          );

          const targetPos = new THREE.Vector3(
            player.mesh.position.x + offsetX,
            pivotY + offsetY,
            player.mesh.position.z + offsetZ
          );

          const dirToCam = new THREE.Vector3()
            .subVectors(targetPos, lookTarget)
            .normalize();
          const distToCam = targetPos.distanceTo(lookTarget);

          const camRay = new THREE.Raycaster(
            lookTarget,
            dirToCam,
            0,
            distToCam
          );
          const camHits = camRay.intersectObjects(objects);

          if (camHits.length > 0) {
            camera.position.copy(
              camHits[0].point.sub(dirToCam.multiplyScalar(0.5))
            );
          } else {
            camera.position.copy(targetPos);
          }
          camera.lookAt(lookTarget);
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        if (isPlaying) {
          const delta = Math.min(clock.getDelta(), 0.1);
          updatePhysics(delta);
          updateCamera();
          if (isEditorMode) {
            updateEditorPreview();
          } else {
            checkGrappleTarget();
          }

          if (!isEditorMode && player.onGround) {
            const speed = Math.sqrt(
              player.velocity.x ** 2 + player.velocity.z ** 2
            );
            if (speed > 0.1) {
              player.mesh.children[0].position.y =
                0.6 + Math.sin(Date.now() * 0.015) * 0.05;
            }
          }
        }
        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
    </script>
  </body>
</html>
